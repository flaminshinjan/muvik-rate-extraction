/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class DOMBaseNode {
    constructor(isVisible, parent){
        _define_property(this, "isVisible", void 0);
        _define_property(this, "parent", void 0);
        this.isVisible = isVisible;
        this.parent = parent;
    }
}
class DOMTextNode extends DOMBaseNode {
    hasParentWithHighlightIndex() {
        let current = this.parent;
        while(null != current){
            if (void 0 !== current.highlightIndex) return true;
            current = current.parent;
        }
        return false;
    }
    constructor(text, isVisible, parent){
        super(isVisible, parent), _define_property(this, "type", 'TEXT_NODE'), _define_property(this, "text", void 0);
        this.text = text;
    }
}
class DOMElementNode extends DOMBaseNode {
    getAllTextTillNextClickableElement(maxDepth = -1) {
        const textParts = [];
        const collectText = (node, currentDepth)=>{
            if (-1 !== maxDepth && currentDepth > maxDepth) return;
            if (node instanceof DOMElementNode && node !== this && void 0 !== node.highlightIndex) return;
            if (node instanceof DOMTextNode) textParts.push(node.text);
            else if (node instanceof DOMElementNode) for (const child of node.children)collectText(child, currentDepth + 1);
        };
        collectText(this, 0);
        return textParts.join('\n').trim();
    }
    clickableElementsToString(includeAttributes = []) {
        const formattedText = [];
        const processNode = (node, depth)=>{
            if (node instanceof DOMElementNode) {
                if (void 0 !== node.highlightIndex) {
                    let attributesStr = '';
                    if (includeAttributes.length) attributesStr = ` ${includeAttributes.map((key)=>node.attributes[key] ? `${key}="${node.attributes[key]}"` : '').filter(Boolean).join(' ')}`;
                    formattedText.push(`[${node.highlightIndex}]<${node.tagName}${attributesStr}>${node.getAllTextTillNextClickableElement()}</${node.tagName}>`);
                }
                for (const child of node.children)processNode(child, depth + 1);
            } else if (node instanceof DOMTextNode) {
                if (!node.hasParentWithHighlightIndex()) formattedText.push(`[]${node.text}`);
            }
        };
        processNode(this, 0);
        return formattedText.join('\n');
    }
    getFileUploadElement(checkSiblings = true) {
        if ('input' === this.tagName && 'file' === this.attributes['type']) return this;
        for (const child of this.children)if (child instanceof DOMElementNode) {
            const result = child.getFileUploadElement(false);
            if (result) return result;
        }
        if (checkSiblings && this.parent) {
            for (const sibling of this.parent.children)if (sibling !== this && sibling instanceof DOMElementNode) {
                const result = sibling.getFileUploadElement(false);
                if (result) return result;
            }
        }
        return null;
    }
    getAdvancedCssSelector() {
        return this.enhancedCssSelectorForElement();
    }
    convertSimpleXPathToCssSelector(xpath) {
        if (!xpath) return '';
        const cleanXpath = xpath.replace(/^\//, '');
        const parts = cleanXpath.split('/');
        const cssParts = [];
        for (const part of parts)if (!!part) {
            if (part.includes('[')) {
                const bracketIndex = part.indexOf('[');
                let basePart = part.substring(0, bracketIndex);
                const indexPart = part.substring(bracketIndex);
                const indices = indexPart.split(']').slice(0, -1).map((i)=>i.replace('[', ''));
                for (const idx of indices)if (/^\d+$/.test(idx)) try {
                    const index = Number.parseInt(idx, 10) - 1;
                    basePart += `:nth-of-type(${index + 1})`;
                } catch (error) {}
                else if ('last()' === idx) basePart += ':last-of-type';
                else if (idx.includes('position()')) {
                    if (idx.includes('>1')) basePart += ':nth-of-type(n+2)';
                }
                cssParts.push(basePart);
            } else cssParts.push(part);
        }
        const baseSelector = cssParts.join(' > ');
        return baseSelector;
    }
    enhancedCssSelectorForElement(includeDynamicAttributes = true) {
        try {
            if (!this.xpath) return '';
            let cssSelector = this.convertSimpleXPathToCssSelector(this.xpath);
            if (this.attributes['class'] && includeDynamicAttributes) {
                const validClassNamePattern = /^[a-zA-Z_][a-zA-Z0-9_-]*$/;
                const classes = this.attributes['class'].split(/\s+/);
                for (const className of classes)if (!!className.trim()) {
                    if (validClassNamePattern.test(className)) cssSelector += `.${className}`;
                }
            }
            const SAFE_ATTRIBUTES = new Set([
                'id',
                'name',
                'type',
                'value',
                'placeholder',
                'aria-label',
                'aria-labelledby',
                'aria-describedby',
                'role',
                'for',
                'autocomplete',
                'required',
                'readonly',
                'alt',
                'title',
                'src',
                'href',
                'target'
            ]);
            if (includeDynamicAttributes) {
                SAFE_ATTRIBUTES.add('data-id');
                SAFE_ATTRIBUTES.add('data-qa');
                SAFE_ATTRIBUTES.add('data-cy');
                SAFE_ATTRIBUTES.add('data-testid');
            }
            for (const [attribute, value] of Object.entries(this.attributes)){
                if ('class' === attribute) continue;
                if (!attribute.trim()) continue;
                if (!SAFE_ATTRIBUTES.has(attribute)) continue;
                const safeAttribute = attribute.replace(':', '\\:');
                if ('' === value) cssSelector += `[${safeAttribute}]`;
                else if (/["'<>`\n\r\t]/.test(value)) {
                    const collapsedValue = value.replace(/\s+/g, ' ').trim();
                    const safeValue = collapsedValue.replace(/"/g, '\\"');
                    cssSelector += `[${safeAttribute}*="${safeValue}"]`;
                } else cssSelector += `[${safeAttribute}="${value}"]`;
            }
            return cssSelector;
        } catch (error) {
            const tagName = this.tagName || '*';
            return `${tagName}[highlight-index='${this.highlightIndex}']`;
        }
    }
    constructor(params){
        super(params.isVisible, params.parent), _define_property(this, "tagName", void 0), _define_property(this, "xpath", void 0), _define_property(this, "cssSelector", void 0), _define_property(this, "attributes", void 0), _define_property(this, "children", void 0), _define_property(this, "isInteractive", void 0), _define_property(this, "isTopElement", void 0), _define_property(this, "shadowRoot", void 0), _define_property(this, "highlightIndex", void 0), _define_property(this, "viewportCoordinates", void 0), _define_property(this, "pageCoordinates", void 0), _define_property(this, "viewportInfo", void 0);
        this.tagName = params.tagName;
        this.xpath = params.xpath;
        this.cssSelector = params.cssSelector;
        this.attributes = params.attributes;
        this.children = params.children;
        this.isInteractive = params.isInteractive ?? false;
        this.isTopElement = params.isTopElement ?? false;
        this.shadowRoot = params.shadowRoot ?? false;
        this.highlightIndex = params.highlightIndex;
        this.viewportCoordinates = params.viewportCoordinates;
        this.pageCoordinates = params.pageCoordinates;
        this.viewportInfo = params.viewportInfo;
    }
}
function domElementNodeToDict(elementTree) {
    function nodeToDict(node) {
        if (node instanceof DOMTextNode) return {
            type: 'text',
            text: node.text
        };
        if (node instanceof DOMElementNode) return {
            type: 'element',
            tagName: node.tagName,
            attributes: node.attributes,
            highlightIndex: node.highlightIndex,
            children: node.children.map((child)=>nodeToDict(child))
        };
        return {};
    }
    return nodeToDict(elementTree);
}
export { DOMBaseNode, DOMElementNode, DOMTextNode, domElementNodeToDict };

//# sourceMappingURL=views.mjs.map