/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    Action: ()=>Action,
    buildDynamicActionSchema: ()=>buildDynamicActionSchema,
    InvalidInputError: ()=>InvalidInputError,
    ActionBuilder: ()=>ActionBuilder
});
const external_types_js_namespaceObject = require("../types.js");
const external_schemas_js_namespaceObject = require("./schemas.js");
const external_zod_namespaceObject = require("zod");
const external_utils_js_namespaceObject = require("../../utils.js");
const prompts_namespaceObject = require("@langchain/core/prompts");
const types_js_namespaceObject = require("../event/types.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, external_utils_js_namespaceObject.createLogger)('Action');
class InvalidInputError extends Error {
    constructor(message){
        super(message);
        this.name = 'InvalidInputError';
    }
}
class Action {
    async call(input) {
        const schema = this.schema.schema;
        const isEmptySchema = schema instanceof external_zod_namespaceObject.z.ZodObject && 0 === Object.keys(schema.shape || {}).length;
        if (isEmptySchema) return await this.handler({});
        const parsedArgs = this.schema.schema.safeParse(input);
        if (!parsedArgs.success) {
            const errorMessage = parsedArgs.error.message;
            throw new InvalidInputError(errorMessage);
        }
        return await this.handler(parsedArgs.data);
    }
    name() {
        return this.schema.name;
    }
    prompt() {
        const schemaShape = this.schema.schema.shape || {};
        const schemaProperties = Object.entries(schemaShape).map(([key, value])=>{
            const zodValue = value;
            return `'${key}': {'type': '${zodValue.description}', ${zodValue.isOptional() ? "'optional': true" : "'required': true"}}`;
        });
        const schemaStr = schemaProperties.length > 0 ? `{${this.name()}: {${schemaProperties.join(', ')}}}` : `{${this.name()}: {}}`;
        return `${this.schema.description}:\n${schemaStr}`;
    }
    constructor(handler, schema){
        _define_property(this, "handler", void 0);
        _define_property(this, "schema", void 0);
        this.handler = handler;
        this.schema = schema;
    }
}
function buildDynamicActionSchema(actions) {
    let schema = external_zod_namespaceObject.z.object({});
    for (const action of actions){
        const actionSchema = action.schema.schema.nullable();
        schema = schema.extend({
            [action.name()]: actionSchema
        });
    }
    return schema.partial().nullable();
}
class ActionBuilder {
    buildDefaultActions() {
        const actions = [];
        const done = new Action(async (input)=>{
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, external_schemas_js_namespaceObject.doneActionSchema.name);
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, input.text);
            return new external_types_js_namespaceObject.ActionResult({
                isDone: true,
                extractedContent: input.text
            });
        }, external_schemas_js_namespaceObject.doneActionSchema);
        actions.push(done);
        const searchGoogle = new Action(async (input)=>{
            const msg = `Searching for "${input.query}" in Google`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, msg);
            const page = await this.context.browserContext.getCurrentPage();
            await page.navigateTo(`https://www.google.com/search?q=${input.query}`);
            const msg2 = `Searched for "${input.query}" in Google`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg2);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg2,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.searchGoogleActionSchema);
        actions.push(searchGoogle);
        const goToUrl = new Action(async (input)=>{
            const msg = `Navigating to ${input.url}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, msg);
            await this.context.browserContext.navigateTo(input.url);
            const msg2 = `Navigated to ${input.url}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg2);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg2,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.goToUrlActionSchema);
        actions.push(goToUrl);
        const goBack = new Action(async (_input = {})=>{
            const msg = 'Navigating back';
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, msg);
            const page = await this.context.browserContext.getCurrentPage();
            await page.goBack();
            const msg2 = 'Navigated back';
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg2);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg2,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.goBackActionSchema);
        actions.push(goBack);
        const clickElement = new Action(async (input)=>{
            const todo = input.desc || `Click element with index ${input.index}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, todo);
            const page = await this.context.browserContext.getCurrentPage();
            const state = await page.getState();
            const elementNode = null == state ? void 0 : state.selectorMap.get(input.index);
            if (!elementNode) throw new Error(`Element with index ${input.index} does not exist - retry or use alternative actions`);
            if (await page.isFileUploader(elementNode)) {
                const msg = `Index ${input.index} - has an element which opens file upload dialog. To upload files please use a specific function to upload files`;
                logger.info(msg);
                return new external_types_js_namespaceObject.ActionResult({
                    extractedContent: msg,
                    includeInMemory: true
                });
            }
            try {
                console.log('elementNode', elementNode);
                await page.clickElementNode(this.context.options.useVision, elementNode);
                const msg = `Clicked button with index ${input.index}: ${elementNode.getAllTextTillNextClickableElement(2)}`;
                logger.info(msg);
                this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
                return new external_types_js_namespaceObject.ActionResult({
                    extractedContent: msg,
                    includeInMemory: true
                });
            } catch (error) {
                const msg = `Element no longer available with index ${input.index} - most likely the page changed`;
                this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_FAIL, msg);
                return new external_types_js_namespaceObject.ActionResult({
                    error: error instanceof Error ? error.message : String(error)
                });
            }
        }, external_schemas_js_namespaceObject.clickElementActionSchema);
        actions.push(clickElement);
        const inputText = new Action(async (input)=>{
            const todo = input.desc || `Input text into index ${input.index}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, todo);
            const page = await this.context.browserContext.getCurrentPage();
            const state = await page.getState();
            const elementNode = null == state ? void 0 : state.selectorMap.get(input.index);
            if (!elementNode) throw new Error(`Element with index ${input.index} does not exist - retry or use alternative actions`);
            await page.inputTextElementNode(this.context.options.useVision, elementNode, input.text);
            const msg = `Input ${input.text} into index ${input.index}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.inputTextActionSchema);
        actions.push(inputText);
        const switchTab = new Action(async (input)=>{
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, `Switching to tab ${input.tab_id}`);
            await this.context.browserContext.switchTab(input.tab_id);
            const msg = `Switched to tab ${input.tab_id}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.switchTabActionSchema);
        actions.push(switchTab);
        const openTab = new Action(async (input)=>{
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, `Opening ${input.url} in new tab`);
            await this.context.browserContext.openTab(input.url);
            const msg = `Opened ${input.url} in new tab`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.openTabActionSchema);
        actions.push(openTab);
        const extractContent = new Action(async (input)=>{
            const goal = input.goal;
            const page = await this.context.browserContext.getCurrentPage();
            const content = await page.getReadabilityContent();
            const promptTemplate = prompts_namespaceObject.PromptTemplate.fromTemplate('Your task is to extract the content of the page. You will be given a page and a goal and you should extract all relevant information around this goal from the page. If the goal is vague, summarize the page. Respond in json format. Extraction goal: {goal}, Page: {page}');
            const prompt = await promptTemplate.invoke({
                goal,
                page: null == content ? void 0 : content.content
            });
            try {
                const output = await this.extractorLLM.invoke(prompt);
                const msg = `📄  Extracted from page\n: ${output.content}\n`;
                return new external_types_js_namespaceObject.ActionResult({
                    extractedContent: msg,
                    includeInMemory: true
                });
            } catch (error) {
                logger.error(`Error extracting content: ${error instanceof Error ? error.message : String(error)}`);
                const msg = 'Failed to extract content from page, you need to extract content from the current state of the page and store it in the memory. Then scroll down if you still need more information.';
                return new external_types_js_namespaceObject.ActionResult({
                    extractedContent: msg,
                    includeInMemory: true
                });
            }
        }, external_schemas_js_namespaceObject.extractContentActionSchema);
        actions.push(extractContent);
        const cacheContent = new Action(async (input)=>{
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, external_schemas_js_namespaceObject.cacheContentActionSchema.name);
            const msg = `Cached findings: ${input.content}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.cacheContentActionSchema);
        actions.push(cacheContent);
        const scrollDown = new Action(async (input)=>{
            const todo = input.desc || 'Scroll down the page';
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, todo);
            const page = await this.context.browserContext.getCurrentPage();
            await page.scrollDown(input.amount);
            const amount = void 0 !== input.amount ? `${input.amount} pixels` : 'one page';
            const msg = `Scrolled down the page by ${amount}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.scrollDownActionSchema);
        actions.push(scrollDown);
        const scrollUp = new Action(async (input)=>{
            const todo = input.desc || 'Scroll up the page';
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, todo);
            const page = await this.context.browserContext.getCurrentPage();
            await page.scrollUp(input.amount);
            const amount = void 0 !== input.amount ? `${input.amount} pixels` : 'one page';
            const msg = `Scrolled up the page by ${amount}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.scrollUpActionSchema);
        actions.push(scrollUp);
        const sendKeys = new Action(async (input)=>{
            const todo = input.desc || `Send keys: ${input.keys}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, todo);
            const page = await this.context.browserContext.getCurrentPage();
            await page.sendKeys(input.keys);
            const msg = `Sent keys: ${input.keys}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
            return new external_types_js_namespaceObject.ActionResult({
                extractedContent: msg,
                includeInMemory: true
            });
        }, external_schemas_js_namespaceObject.sendKeysActionSchema);
        actions.push(sendKeys);
        const scrollToText = new Action(async (input)=>{
            const todo = input.desc || `Scroll to text: ${input.text}`;
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_START, todo);
            const page = await this.context.browserContext.getCurrentPage();
            try {
                const scrolled = await page.scrollToText(input.text);
                const msg = scrolled ? `Scrolled to text: ${input.text}` : `Text '${input.text}' not found or not visible on page`;
                this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_OK, msg);
                return new external_types_js_namespaceObject.ActionResult({
                    extractedContent: msg,
                    includeInMemory: true
                });
            } catch (error) {
                const msg = `Failed to scroll to text: ${error instanceof Error ? error.message : String(error)}`;
                this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_FAIL, msg);
                return new external_types_js_namespaceObject.ActionResult({
                    error: msg,
                    includeInMemory: true
                });
            }
        }, external_schemas_js_namespaceObject.scrollToTextActionSchema);
        actions.push(scrollToText);
        return actions;
    }
    constructor(context, extractorLLM){
        _define_property(this, "context", void 0);
        _define_property(this, "extractorLLM", void 0);
        this.context = context;
        this.extractorLLM = extractorLLM;
    }
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

//# sourceMappingURL=builder.js.map