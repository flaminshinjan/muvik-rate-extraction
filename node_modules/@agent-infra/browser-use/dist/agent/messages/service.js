/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    default: ()=>MessageManager
});
const messages_namespaceObject = require("@langchain/core/messages");
const external_zod_to_json_schema_namespaceObject = require("zod-to-json-schema");
const external_zod_namespaceObject = require("zod");
const external_views_js_namespaceObject = require("./views.js");
const external_utils_js_namespaceObject = require("../../utils.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, external_utils_js_namespaceObject.createLogger)('MessageManager');
class MessageManager {
    initTaskMessages(systemMessage, task, messageContext) {
        this.addMessageWithTokens(systemMessage);
        if (messageContext && messageContext.length > 0) {
            const contextMessage = new messages_namespaceObject.HumanMessage({
                content: `Context for the task: ${messageContext}`
            });
            this.addMessageWithTokens(contextMessage);
        }
        const taskMessage = MessageManager.taskInstructions(task);
        this.addMessageWithTokens(taskMessage);
        if (this.sensitiveData) {
            const info = `Here are placeholders for sensitive data: ${Object.keys(this.sensitiveData)}`;
            const infoMessage = new messages_namespaceObject.HumanMessage({
                content: `${info}\nTo use them, write <secret>the placeholder name</secret>`
            });
            this.addMessageWithTokens(infoMessage);
        }
        const placeholderMessage = new messages_namespaceObject.HumanMessage({
            content: 'Example output:'
        });
        this.addMessageWithTokens(placeholderMessage);
        const toolCallId = this.nextToolId();
        const toolCalls = [
            {
                name: 'navigator_output',
                description: 'Navigate to the page and click on the element',
                parameters: (0, external_zod_to_json_schema_namespaceObject.zodToJsonSchema)(external_zod_namespaceObject.z.object({
                    current_state: external_zod_namespaceObject.z.object({
                        page_summary: external_zod_namespaceObject.z.string(),
                        evaluation_previous_goal: external_zod_namespaceObject.z.string(),
                        memory: external_zod_namespaceObject.z.string(),
                        next_goal: external_zod_namespaceObject.z.string()
                    }),
                    action: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.object({
                        click_element: external_zod_namespaceObject.z.object({
                            index: external_zod_namespaceObject.z.number()
                        })
                    }))
                })),
                args: {
                    current_state: {
                        page_summary: 'On the page are company a,b,c wtih their revenue 1,2,3.',
                        evaluation_previous_goal: 'Success - I opend the first page',
                        memory: 'Starting with the new task. I have completed 1/10 steps',
                        next_goal: 'Click on company a'
                    },
                    action: [
                        {
                            click_element: {
                                index: 0
                            }
                        }
                    ]
                },
                id: String(toolCallId),
                type: 'tool_call'
            }
        ];
        const exampleToolCall = new messages_namespaceObject.AIMessage({
            content: 'example tool call',
            tool_calls: toolCalls
        });
        this.addMessageWithTokens(exampleToolCall);
        const toolMessage = new messages_namespaceObject.ToolMessage({
            content: 'Browser started',
            tool_call_id: String(toolCallId)
        });
        this.addMessageWithTokens(toolMessage);
        const historyStartMessage = new messages_namespaceObject.HumanMessage({
            content: '[Your task history memory starts here]'
        });
        this.addMessageWithTokens(historyStartMessage);
    }
    nextToolId() {
        const id = this.toolId;
        this.toolId += 1;
        return id;
    }
    static taskInstructions(task) {
        const content = `Your ultimate task is: """${task}""". If you achieved your ultimate task, stop everything and use the done action in the next step to complete the task. If not, continue as usual.`;
        return new messages_namespaceObject.HumanMessage({
            content
        });
    }
    length() {
        return this.history.messages.length;
    }
    addNewTask(newTask) {
        const content = `Your new ultimate task is: """${newTask}""". Take the previous context into account and finish your new ultimate task. `;
        const msg = new messages_namespaceObject.HumanMessage({
            content
        });
        this.addMessageWithTokens(msg);
    }
    addPlan(plan, position) {
        if (plan) {
            const msg = new messages_namespaceObject.AIMessage({
                content: plan
            });
            this.addMessageWithTokens(msg, position);
        }
    }
    addStateMessage(stateMessage) {
        this.addMessageWithTokens(stateMessage);
    }
    removeLastStateMessage() {
        this.history.removeLastHumanMessage();
    }
    getMessages() {
        const messages = this.history.messages.map((m)=>m.message);
        logger.debug(`Messages in history: ${this.history.messages.length}:`);
        for (const m of this.history.messages)m.metadata.inputTokens;
        return messages;
    }
    getMessagesWithTokens() {
        return this.history.messages;
    }
    addMessageWithTokens(message, position) {
        let filteredMessage = message;
        if (this.sensitiveData) filteredMessage = this._filterSensitiveData(message);
        const tokenCount = this._countTokens(filteredMessage);
        const metadata = {
            inputTokens: tokenCount
        };
        this.history.addMessage(filteredMessage, metadata, position);
    }
    _filterSensitiveData(message) {
        const replaceSensitive = (value)=>{
            let filteredValue = value;
            if (!this.sensitiveData) return filteredValue;
            for (const [key, val] of Object.entries(this.sensitiveData))filteredValue = filteredValue.replace(val, `<secret>${key}</secret>`);
            return filteredValue;
        };
        if ('string' == typeof message.content) message.content = replaceSensitive(message.content);
        else if (Array.isArray(message.content)) message.content = message.content.map((item)=>{
            if ('object' == typeof item && 'text' in item) return {
                ...item,
                text: replaceSensitive(item.text)
            };
            return item;
        });
        return message;
    }
    _countTokens(message) {
        let tokens = 0;
        if (Array.isArray(message.content)) {
            for (const item of message.content)if ('image_url' in item) tokens += this.IMG_TOKENS;
            else if ('object' == typeof item && 'text' in item) tokens += this._countTextTokens(item.text);
        } else {
            let msg = message.content;
            if ('tool_calls' in message) msg += JSON.stringify(message.tool_calls);
            tokens += this._countTextTokens(msg);
        }
        return tokens;
    }
    _countTextTokens(text) {
        return Math.floor(text.length / this.estimatedCharactersPerToken);
    }
    cutMessages() {
        let diff = this.history.totalTokens - this.maxInputTokens;
        if (diff <= 0) return;
        const lastMsg = this.history.messages[this.history.messages.length - 1];
        if (Array.isArray(lastMsg.message.content)) {
            let text = '';
            lastMsg.message.content = lastMsg.message.content.filter((item)=>{
                if ('image_url' in item) {
                    diff -= this.IMG_TOKENS;
                    lastMsg.metadata.inputTokens -= this.IMG_TOKENS;
                    this.history.totalTokens -= this.IMG_TOKENS;
                    logger.debug(`Removed image with ${this.IMG_TOKENS} tokens - total tokens now: ${this.history.totalTokens}/${this.maxInputTokens}`);
                    return false;
                }
                if ('text' in item) text += item.text;
                return true;
            });
            lastMsg.message.content = text;
            this.history.messages[this.history.messages.length - 1] = lastMsg;
        }
        if (diff <= 0) return;
        const proportionToRemove = diff / lastMsg.metadata.inputTokens;
        if (proportionToRemove > 0.99) throw new Error(`Max token limit reached - history is too long - reduce the system prompt or task. proportion_to_remove: ${proportionToRemove}`);
        logger.debug(`Removing ${(100 * proportionToRemove).toFixed(2)}% of the last message (${(proportionToRemove * lastMsg.metadata.inputTokens).toFixed(2)} / ${lastMsg.metadata.inputTokens.toFixed(2)} tokens)`);
        const content = lastMsg.message.content;
        const charactersToRemove = Math.floor(content.length * proportionToRemove);
        const newContent = content.slice(0, -charactersToRemove);
        this.history.removeMessage(-1);
        const msg = new messages_namespaceObject.HumanMessage({
            content: newContent
        });
        this.addMessageWithTokens(msg);
        const finalMsg = this.history.messages[this.history.messages.length - 1];
        logger.debug(`Added message with ${finalMsg.metadata.inputTokens} tokens - total tokens now: ${this.history.totalTokens}/${this.maxInputTokens} - total messages: ${this.history.messages.length}`);
    }
    convertMessagesForNonFunctionCallingModels(inputMessages) {
        return inputMessages.map((message)=>{
            if (message instanceof messages_namespaceObject.HumanMessage || message instanceof messages_namespaceObject.SystemMessage) return message;
            if (message instanceof messages_namespaceObject.ToolMessage) return new messages_namespaceObject.HumanMessage({
                content: message.content
            });
            if (message instanceof messages_namespaceObject.AIMessage) {
                if ('tool_calls' in message) {
                    const toolCalls = JSON.stringify(message.tool_calls);
                    return new messages_namespaceObject.AIMessage({
                        content: toolCalls
                    });
                }
                return message;
            }
            throw new Error(`Unknown message type: ${message.constructor.name}`);
        });
    }
    mergeSuccessiveMessages(messages, classToMerge) {
        const mergedMessages = [];
        let streak = 0;
        for (const message of messages)if (message instanceof classToMerge) {
            streak += 1;
            if (streak > 1) {
                const lastMessage = mergedMessages[mergedMessages.length - 1];
                if (Array.isArray(message.content)) {
                    const firstContent = message.content[0];
                    if ('text' in firstContent) lastMessage.content += firstContent.text;
                } else lastMessage.content += message.content;
            } else mergedMessages.push(message);
        } else {
            mergedMessages.push(message);
            streak = 0;
        }
        return mergedMessages;
    }
    constructor({ maxInputTokens = 128000, estimatedCharactersPerToken = 3, imageTokens = 800, sensitiveData } = {}){
        _define_property(this, "maxInputTokens", void 0);
        _define_property(this, "history", void 0);
        _define_property(this, "estimatedCharactersPerToken", void 0);
        _define_property(this, "IMG_TOKENS", void 0);
        _define_property(this, "sensitiveData", void 0);
        _define_property(this, "toolId", void 0);
        this.maxInputTokens = maxInputTokens;
        this.history = new external_views_js_namespaceObject.MessageHistory();
        this.estimatedCharactersPerToken = estimatedCharactersPerToken;
        this.IMG_TOKENS = imageTokens;
        this.sensitiveData = sensitiveData;
        this.toolId = 1;
    }
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

//# sourceMappingURL=service.js.map