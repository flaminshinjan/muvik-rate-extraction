/**
 * The following code is modified based on
 * https://github.com/nanobrowser/nanobrowser/blob/master/chrome-extension/src/background/agent/messages/service.ts
 *
 * Apache-2.0 License
 * Copyright (c) 2024 alexchenzl
 * https://github.com/nanobrowser/nanobrowser/blob/master/LICENSE
 */
import { type BaseMessage, HumanMessage, SystemMessage } from '@langchain/core/messages';
import { type ManagedMessage } from './views';
export default class MessageManager {
    private maxInputTokens;
    private history;
    private estimatedCharactersPerToken;
    private readonly IMG_TOKENS;
    private sensitiveData?;
    private toolId;
    constructor({ maxInputTokens, estimatedCharactersPerToken, imageTokens, sensitiveData, }?: {
        maxInputTokens?: number;
        estimatedCharactersPerToken?: number;
        imageTokens?: number;
        sensitiveData?: Record<string, string>;
    });
    initTaskMessages(systemMessage: SystemMessage, task: string, messageContext?: string): void;
    nextToolId(): number;
    /**
     * Createthe task instructions
     * @param task - The raw description of the task
     * @returns A HumanMessage object containing the task instructions
     */
    private static taskInstructions;
    /**
     * Returns the number of messages in the history
     * @returns The number of messages in the history
     */
    length(): number;
    /**
     * Adds a new task to execute, it will be executed based on the history
     * @param newTask - The raw description of the new task
     */
    addNewTask(newTask: string): void;
    /**
     * Adds a plan message to the history
     * @param plan - The raw description of the plan
     * @param position - The position to add the plan
     */
    addPlan(plan?: string, position?: number): void;
    /**
     * Adds a state message to the history
     * @param stateMessage - The HumanMessage object containing the state
     */
    addStateMessage(stateMessage: HumanMessage): void;
    /**
     * Removes the last state message from the history
     */
    removeLastStateMessage(): void;
    getMessages(): BaseMessage[];
    getMessagesWithTokens(): ManagedMessage[];
    /**
     * Adds a message to the history with the token count metadata
     * @param message - The BaseMessage object to add
     * @param position - The optional position to add the message, if not provided, the message will be added to the end of the history
     */
    addMessageWithTokens(message: BaseMessage, position?: number): void;
    /**
     * Filters out sensitive data from the message
     * @param message - The BaseMessage object to filter
     * @returns The filtered BaseMessage object
     */
    private _filterSensitiveData;
    /**
     * Counts the tokens in the message
     * @param message - The BaseMessage object to count the tokens
     * @returns The number of tokens in the message
     */
    private _countTokens;
    /**
     * Counts the tokens in the text
     * Rough estimate, no tokenizer provided for now
     * @param text - The text to count the tokens
     * @returns The number of tokens in the text
     */
    private _countTextTokens;
    /**
     * Cuts the last message if the total tokens exceed the max input tokens
     *
     * Get current message list, potentially trimmed to max tokens
     */
    cutMessages(): void;
    /**
     * Converts messages for non-function-calling models
     * @param inputMessages - The BaseMessage objects to convert
     * @returns The converted BaseMessage objects
     */
    convertMessagesForNonFunctionCallingModels(inputMessages: BaseMessage[]): BaseMessage[];
    /**
     * Some models like deepseek-reasoner dont allow multiple human messages in a row. This function merges them into one."
     * @param messages - The BaseMessage objects to merge
     * @param classToMerge - The class of the messages to merge
     * @returns The merged BaseMessage objects
     */
    mergeSuccessiveMessages(messages: BaseMessage[], classToMerge: typeof BaseMessage): BaseMessage[];
}
//# sourceMappingURL=service.d.ts.map