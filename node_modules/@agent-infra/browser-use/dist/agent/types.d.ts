/**
 * The following code is modified based on
 * https://github.com/nanobrowser/nanobrowser/blob/master/chrome-extension/src/background/agent/types.ts
 *
 * Apache-2.0 License
 * Copyright (c) 2024 alexchenzl
 * https://github.com/nanobrowser/nanobrowser/blob/master/LICENSE
 */
import { z } from 'zod';
import type BrowserContext from '../browser/context';
import type MessageManager from './messages/service';
import type { EventManager } from './event/manager';
import { type Actors, type ExecutionState } from './event/types';
import { BrowserState } from '../browser/types';
export interface AgentOptions {
    maxSteps: number;
    maxActionsPerStep: number;
    maxFailures: number;
    retryDelay: number;
    maxInputTokens: number;
    maxErrorLength: number;
    useVision: boolean;
    useVisionForPlanner: boolean;
    validateOutput: boolean;
    includeAttributes: string[];
    planningInterval: number;
}
export declare const DEFAULT_AGENT_OPTIONS: AgentOptions;
export declare class AgentContext {
    taskId: string;
    browserContext: BrowserContext;
    messageManager: MessageManager;
    eventManager: EventManager;
    options: AgentOptions;
    paused: boolean;
    stopped: boolean;
    consecutiveFailures: number;
    nSteps: number;
    stepInfo: AgentStepInfo | null;
    actionResults: ActionResult[];
    stateMessageAdded: boolean;
    constructor(taskId: string, browserContext: BrowserContext, messageManager: MessageManager, eventManager: EventManager, options: Partial<AgentOptions>);
    emitEvent(actor: Actors, state: ExecutionState, eventDetails: string, browserState?: BrowserState): Promise<void>;
    pause(): Promise<void>;
    resume(): Promise<void>;
    stop(): Promise<void>;
}
export declare class AgentStepInfo {
    stepNumber: number;
    maxSteps: number;
    constructor(params: {
        stepNumber: number;
        maxSteps: number;
    });
}
interface ActionResultParams {
    isDone?: boolean;
    extractedContent?: string | null;
    error?: string | null;
    includeInMemory?: boolean;
}
export declare class ActionResult {
    isDone: boolean;
    extractedContent: string | null;
    error: string | null;
    includeInMemory: boolean;
    constructor(params?: ActionResultParams);
}
export type WrappedActionResult = ActionResult & {
    toolCallId: string;
};
export declare const agentBrainSchema: z.ZodObject<{
    page_summary: z.ZodString;
    evaluation_previous_goal: z.ZodString;
    memory: z.ZodString;
    next_goal: z.ZodString;
}, "strip", z.ZodTypeAny, {
    page_summary: string;
    evaluation_previous_goal: string;
    memory: string;
    next_goal: string;
}, {
    page_summary: string;
    evaluation_previous_goal: string;
    memory: string;
    next_goal: string;
}>;
export type AgentBrain = z.infer<typeof agentBrainSchema>;
export interface AgentOutput<T = unknown> {
    /**
     * The unique identifier for the agent
     */
    id: string;
    /**
     * The result of the agent's step
     */
    result?: T;
    /**
     * The error that occurred during the agent's action
     */
    error?: string;
}
export {};
//# sourceMappingURL=types.d.ts.map