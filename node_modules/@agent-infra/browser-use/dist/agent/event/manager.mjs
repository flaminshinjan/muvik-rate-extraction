/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import * as __WEBPACK_EXTERNAL_MODULE__utils_mjs_e798cd09__ from "../../utils.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, __WEBPACK_EXTERNAL_MODULE__utils_mjs_e798cd09__.createLogger)('event-manager');
class EventManager {
    subscribe(eventType, callback) {
        if (!this._subscribers.has(eventType)) this._subscribers.set(eventType, []);
        const callbacks = this._subscribers.get(eventType);
        if (callbacks && !callbacks.includes(callback)) callbacks.push(callback);
    }
    unsubscribe(eventType, callback) {
        if (this._subscribers.has(eventType)) {
            const callbacks = this._subscribers.get(eventType);
            if (callbacks) this._subscribers.set(eventType, callbacks.filter((cb)=>cb !== callback));
        }
    }
    clearSubscribers(eventType) {
        if (this._subscribers.has(eventType)) this._subscribers.set(eventType, []);
    }
    async emit(event) {
        const callbacks = this._subscribers.get(event.type);
        if (callbacks) try {
            await Promise.all(callbacks.map(async (callback)=>await callback(event)));
        } catch (error) {
            logger.error('Error executing event callbacks:', error);
        }
    }
    constructor(){
        _define_property(this, "_subscribers", void 0);
        this._subscribers = new Map();
    }
}
export { EventManager };

//# sourceMappingURL=manager.mjs.map