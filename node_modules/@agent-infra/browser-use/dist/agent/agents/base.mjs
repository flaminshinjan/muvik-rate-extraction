/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import * as __WEBPACK_EXTERNAL_MODULE_jsonrepair__ from "jsonrepair";
import * as __WEBPACK_EXTERNAL_MODULE__langchain_core_messages_57fab301__ from "@langchain/core/messages";
import * as __WEBPACK_EXTERNAL_MODULE__utils_mjs_e798cd09__ from "../../utils.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, __WEBPACK_EXTERNAL_MODULE__utils_mjs_e798cd09__.createLogger)('agent');
const THINK_TAGS = /<think>[\s\S]*?<\/think>/;
class BaseAgent {
    setModelNames() {
        if ('model_name' in this.chatLLM) return this.chatLLM.model_name;
        if ('model' in this.chatLLM) return this.chatLLM.model;
        return 'Unknown';
    }
    setToolCallingMethod(toolCallingMethod) {
        if ('auto' === toolCallingMethod) switch(this.chatModelLibrary){
            case 'ChatGoogleGenerativeAI':
                return null;
            case 'ChatOpenAI':
            case 'AzureChatOpenAI':
                return 'function_calling';
            default:
                return null;
        }
        return toolCallingMethod || null;
    }
    setWithStructuredOutput() {
        if ('deepseek-reasoner' === this.modelName || 'deepseek-r1' === this.modelName || this.modelName.includes('claude')) return false;
        return true;
    }
    removeThinkTags(text) {
        return text.replace(THINK_TAGS, '');
    }
    async invoke(inputMessages) {
        if (this.withStructuredOutput) {
            const structuredLlm = this.chatLLM.withStructuredOutput(this.modelOutputSchema, {
                includeRaw: true,
                name: this.modelOutputToolName,
                strict: true
            });
            const response = await structuredLlm.invoke(inputMessages, {
                ...this.callOptions
            });
            if (response.parsed) return response.parsed;
            throw new Error('Could not parse response');
        }
        const response = await this.chatLLM.invoke(inputMessages, {
            ...this.callOptions
        });
        if ('string' == typeof response.content) {
            response.content = this.removeThinkTags(response.content);
            try {
                const extractedJson = this.extractJsonFromModelOutput(response.content);
                const parsed = this.validateModelOutput(extractedJson);
                if (parsed) return parsed;
            } catch (error) {
                logger.error('Could not parse response', response);
            }
        }
        throw new Error('Could not parse response');
    }
    validateModelOutput(data) {
        if (!this.modelOutputSchema || !data) return;
        return this.modelOutputSchema.parse(data);
    }
    addModelOutputToMemory(modelOutput) {
        const messageManager = this.context.messageManager;
        const toolCallId = String(messageManager.nextToolId());
        const toolCalls = [
            {
                name: this.modelOutputToolName,
                args: modelOutput,
                id: toolCallId,
                type: 'tool_call'
            }
        ];
        const toolCallMessage = new __WEBPACK_EXTERNAL_MODULE__langchain_core_messages_57fab301__.AIMessage({
            content: 'tool call',
            tool_calls: toolCalls
        });
        messageManager.addMessageWithTokens(toolCallMessage);
        const toolMessage = new __WEBPACK_EXTERNAL_MODULE__langchain_core_messages_57fab301__.ToolMessage({
            content: 'tool call response placeholder',
            tool_call_id: toolCallId
        });
        messageManager.addMessageWithTokens(toolMessage);
    }
    extractJsonFromModelOutput(content) {
        try {
            let cleanedContent = content;
            if (content.includes('```')) {
                cleanedContent = cleanedContent.split('```')[1];
                if (cleanedContent.includes('\n')) cleanedContent = cleanedContent.split('\n', 2)[1];
            } else {
                const jsonRegex = /(\{(?:[^{}]|(?:\{(?:[^{}]|(?:\{[^{}]*\}))*\}))*\})/;
                const match = cleanedContent.match(jsonRegex);
                if (match && match[1]) cleanedContent = match[1];
            }
            cleanedContent = (0, __WEBPACK_EXTERNAL_MODULE_jsonrepair__.jsonrepair)(cleanedContent);
            return JSON.parse(cleanedContent);
        } catch (e) {
            logger.warning(`Failed to parse model output: ${content} ${e}`);
            throw new Error('Could not parse response.');
        }
    }
    constructor(modelOutputSchema, options, extraOptions){
        _define_property(this, "id", void 0);
        _define_property(this, "chatLLM", void 0);
        _define_property(this, "prompt", void 0);
        _define_property(this, "context", void 0);
        _define_property(this, "actions", {});
        _define_property(this, "modelOutputSchema", void 0);
        _define_property(this, "toolCallingMethod", void 0);
        _define_property(this, "chatModelLibrary", void 0);
        _define_property(this, "modelName", void 0);
        _define_property(this, "withStructuredOutput", void 0);
        _define_property(this, "callOptions", void 0);
        _define_property(this, "modelOutputToolName", void 0);
        this.modelOutputSchema = modelOutputSchema;
        this.chatLLM = options.chatLLM;
        this.prompt = options.prompt;
        this.context = options.context;
        this.chatModelLibrary = this.chatLLM.constructor.name;
        this.modelName = this.setModelNames();
        this.withStructuredOutput = this.setWithStructuredOutput();
        this.id = (null == extraOptions ? void 0 : extraOptions.id) || 'agent';
        this.toolCallingMethod = this.setToolCallingMethod(null == extraOptions ? void 0 : extraOptions.toolCallingMethod);
        this.callOptions = null == extraOptions ? void 0 : extraOptions.callOptions;
        this.modelOutputToolName = `${this.id}_output`;
    }
}
export { BaseAgent };

//# sourceMappingURL=base.mjs.map