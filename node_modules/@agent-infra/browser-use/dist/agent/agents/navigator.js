/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    NavigatorActionRegistry: ()=>NavigatorActionRegistry,
    NavigatorAgent: ()=>NavigatorAgent
});
const external_zod_namespaceObject = require("zod");
const external_base_js_namespaceObject = require("./base.js");
const external_types_js_namespaceObject = require("../types.js");
const builder_js_namespaceObject = require("../actions/builder.js");
const messages_namespaceObject = require("@langchain/core/messages");
const types_js_namespaceObject = require("../event/types.js");
const external_utils_js_namespaceObject = require("../../utils.js");
const external_errors_js_namespaceObject = require("./errors.js");
const json_schema_js_namespaceObject = require("../actions/json_schema.js");
const json_gemini_js_namespaceObject = require("../actions/json_gemini.js");
const external_jsonrepair_namespaceObject = require("jsonrepair");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, external_utils_js_namespaceObject.createLogger)('NavigatorAgent');
class NavigatorActionRegistry {
    registerAction(action) {
        this.actions[action.name()] = action;
    }
    unregisterAction(name) {
        delete this.actions[name];
    }
    getAction(name) {
        return this.actions[name];
    }
    setupModelOutputSchema() {
        const actionSchema = (0, builder_js_namespaceObject.buildDynamicActionSchema)(Object.values(this.actions));
        return external_zod_namespaceObject.z.object({
            current_state: external_types_js_namespaceObject.agentBrainSchema,
            action: external_zod_namespaceObject.z.array(actionSchema)
        });
    }
    constructor(actions){
        _define_property(this, "actions", {});
        for (const action of actions)this.registerAction(action);
    }
}
class NavigatorAgent extends external_base_js_namespaceObject.BaseAgent {
    async invoke(inputMessages) {
        logger.info('invoke this.chatLLM', this.withStructuredOutput);
        if (this.withStructuredOutput) {
            const schema = 'ChatGoogleGenerativeAI' === this.chatModelLibrary ? json_gemini_js_namespaceObject.geminiNavigatorOutputSchema : json_schema_js_namespaceObject.jsonNavigatorOutputSchema;
            const structuredLlm = this.chatLLM.withStructuredOutput(schema, {
                includeRaw: true
            });
            console.log('structuredLlm', structuredLlm);
            const response = await structuredLlm.invoke(inputMessages, {
                ...this.callOptions
            });
            logger.info('invoke structuredLlm response', response);
            if (response.parsed) return response.parsed;
            return response.raw;
        }
        const response = await this.chatLLM.invoke(inputMessages, {
            ...this.callOptions
        });
        logger.info('invoke response', response);
        if ('string' == typeof response.content) {
            response.content = this.removeThinkTags(response.content);
            try {
                const extractedJson = this.extractJsonFromModelOutput(response.content);
                const parsed = this.validateModelOutput(extractedJson);
                if (parsed) return parsed;
            } catch (error) {
                logger.error('Could not parse response', response);
            }
        }
        throw new Error('Could not parse response');
    }
    async execute() {
        const agentOutput = {
            id: this.id
        };
        let cancelled = false;
        try {
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.STEP_START, 'Navigating...');
            const messageManager = this.context.messageManager;
            await this.addStateMessageToMemory();
            if (this.context.paused || this.context.stopped) {
                cancelled = true;
                return agentOutput;
            }
            const inputMessages = messageManager.getMessages();
            const modelOutput = await this.invoke(inputMessages);
            logger.info('modelOutput', modelOutput);
            if (this.context.paused || this.context.stopped) {
                cancelled = true;
                return agentOutput;
            }
            this.removeLastStateMessageFromMemory();
            this.addModelOutputToMemory(modelOutput);
            logger.info('modelOutput.action', modelOutput.action);
            const actionResults = await this.doMultiAction(modelOutput);
            logger.info('actionResults', actionResults);
            this.context.actionResults = actionResults;
            if (this.context.paused || this.context.stopped) {
                cancelled = true;
                return agentOutput;
            }
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.STEP_OK, 'Navigation done');
            let done = false;
            if (actionResults.length > 0 && actionResults[actionResults.length - 1].isDone) done = true;
            agentOutput.result = {
                done
            };
            return agentOutput;
        } catch (error) {
            logger.error('execute error', error);
            this.removeLastStateMessageFromMemory();
            if ((0, external_utils_js_namespaceObject.isAuthenticationError)(error)) throw new external_errors_js_namespaceObject.ChatModelAuthError('Navigator API Authentication failed. Please verify your API key', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            const errorString = `Navigation failed: ${errorMessage}`;
            logger.error(errorString);
            this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.STEP_FAIL, errorString);
            agentOutput.error = errorMessage;
            return agentOutput;
        } finally{
            if (cancelled) {
                this.removeLastStateMessageFromMemory();
                this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.STEP_CANCEL, 'Navigation cancelled');
            }
        }
    }
    async addStateMessageToMemory() {
        if (this.context.stateMessageAdded) return;
        const messageManager = this.context.messageManager;
        const options = this.context.options;
        if (this.context.actionResults.length > 0) {
            let index = 0;
            for (const r of this.context.actionResults){
                if (r.includeInMemory) {
                    if (r.extractedContent) {
                        const msg = new messages_namespaceObject.HumanMessage(`Action result: ${r.extractedContent}`);
                        messageManager.addMessageWithTokens(msg);
                    }
                    if (r.error) {
                        const msg = new messages_namespaceObject.HumanMessage(`Action error: ${r.error.toString().slice(-options.maxErrorLength)}`);
                        logger.info('Adding action error to memory', msg.content);
                        messageManager.addMessageWithTokens(msg);
                    }
                    this.context.actionResults[index] = new external_types_js_namespaceObject.ActionResult();
                }
                index++;
            }
        }
        const state = await this.prompt.getUserMessage(this.context);
        messageManager.addStateMessage(state);
        this.context.stateMessageAdded = true;
    }
    async removeLastStateMessageFromMemory() {
        if (!this.context.stateMessageAdded) return;
        const messageManager = this.context.messageManager;
        messageManager.removeLastStateMessage();
        this.context.stateMessageAdded = false;
    }
    async doMultiAction(response) {
        const results = [];
        let errCount = 0;
        logger.info('doMultiAction_Actions', response.action);
        let actions = [];
        if (Array.isArray(response.action)) {
            actions = response.action.filter((item)=>null !== item);
            if (0 === actions.length) logger.warning('No valid actions found', response.action);
        } else if ('string' == typeof response.action) try {
            logger.warning('Unexpected action format', response.action);
            const repaired = (0, external_jsonrepair_namespaceObject.jsonrepair)(response.action);
            actions = JSON.parse(repaired);
        } catch (error) {
            logger.error('Invalid action format', response.action);
            throw new Error('Invalid action output format');
        }
        else actions = [
            response.action
        ];
        for (const action of actions){
            const actionName = Object.keys(action)[0];
            const actionArgs = action[actionName];
            try {
                var _this_actionRegistry_getAction;
                if (this.context.paused || this.context.stopped) return results;
                const result = await (null === (_this_actionRegistry_getAction = this.actionRegistry.getAction(actionName)) || void 0 === _this_actionRegistry_getAction ? void 0 : _this_actionRegistry_getAction.call(actionArgs));
                if (void 0 === result) throw new Error(`Action ${actionName} not exists or returned undefined`);
                results.push(result);
                if (this.context.paused || this.context.stopped) return results;
                await new Promise((resolve)=>setTimeout(resolve, 1000));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger.error('doAction error', errorMessage);
                this.context.emitEvent(types_js_namespaceObject.Actors.NAVIGATOR, types_js_namespaceObject.ExecutionState.ACT_FAIL, errorMessage);
                errCount++;
                if (errCount > 3) throw new Error('Too many errors in actions');
                results.push(new external_types_js_namespaceObject.ActionResult({
                    error: errorMessage,
                    isDone: false,
                    includeInMemory: true
                }));
            }
        }
        return results;
    }
    constructor(actionRegistry, options, extraOptions){
        super(actionRegistry.setupModelOutputSchema(), options, {
            ...extraOptions,
            id: 'navigator'
        }), _define_property(this, "actionRegistry", void 0);
        this.actionRegistry = actionRegistry;
    }
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

//# sourceMappingURL=navigator.js.map