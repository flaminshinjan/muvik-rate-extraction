/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    BaseAgent: ()=>BaseAgent
});
const external_jsonrepair_namespaceObject = require("jsonrepair");
const messages_namespaceObject = require("@langchain/core/messages");
const external_utils_js_namespaceObject = require("../../utils.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, external_utils_js_namespaceObject.createLogger)('agent');
const THINK_TAGS = /<think>[\s\S]*?<\/think>/;
class BaseAgent {
    setModelNames() {
        if ('model_name' in this.chatLLM) return this.chatLLM.model_name;
        if ('model' in this.chatLLM) return this.chatLLM.model;
        return 'Unknown';
    }
    setToolCallingMethod(toolCallingMethod) {
        if ('auto' === toolCallingMethod) switch(this.chatModelLibrary){
            case 'ChatGoogleGenerativeAI':
                return null;
            case 'ChatOpenAI':
            case 'AzureChatOpenAI':
                return 'function_calling';
            default:
                return null;
        }
        return toolCallingMethod || null;
    }
    setWithStructuredOutput() {
        if ('deepseek-reasoner' === this.modelName || 'deepseek-r1' === this.modelName || this.modelName.includes('claude')) return false;
        return true;
    }
    removeThinkTags(text) {
        return text.replace(THINK_TAGS, '');
    }
    async invoke(inputMessages) {
        if (this.withStructuredOutput) {
            const structuredLlm = this.chatLLM.withStructuredOutput(this.modelOutputSchema, {
                includeRaw: true,
                name: this.modelOutputToolName,
                strict: true
            });
            const response = await structuredLlm.invoke(inputMessages, {
                ...this.callOptions
            });
            if (response.parsed) return response.parsed;
            throw new Error('Could not parse response');
        }
        const response = await this.chatLLM.invoke(inputMessages, {
            ...this.callOptions
        });
        if ('string' == typeof response.content) {
            response.content = this.removeThinkTags(response.content);
            try {
                const extractedJson = this.extractJsonFromModelOutput(response.content);
                const parsed = this.validateModelOutput(extractedJson);
                if (parsed) return parsed;
            } catch (error) {
                logger.error('Could not parse response', response);
            }
        }
        throw new Error('Could not parse response');
    }
    validateModelOutput(data) {
        if (!this.modelOutputSchema || !data) return;
        return this.modelOutputSchema.parse(data);
    }
    addModelOutputToMemory(modelOutput) {
        const messageManager = this.context.messageManager;
        const toolCallId = String(messageManager.nextToolId());
        const toolCalls = [
            {
                name: this.modelOutputToolName,
                args: modelOutput,
                id: toolCallId,
                type: 'tool_call'
            }
        ];
        const toolCallMessage = new messages_namespaceObject.AIMessage({
            content: 'tool call',
            tool_calls: toolCalls
        });
        messageManager.addMessageWithTokens(toolCallMessage);
        const toolMessage = new messages_namespaceObject.ToolMessage({
            content: 'tool call response placeholder',
            tool_call_id: toolCallId
        });
        messageManager.addMessageWithTokens(toolMessage);
    }
    extractJsonFromModelOutput(content) {
        try {
            let cleanedContent = content;
            if (content.includes('```')) {
                cleanedContent = cleanedContent.split('```')[1];
                if (cleanedContent.includes('\n')) cleanedContent = cleanedContent.split('\n', 2)[1];
            } else {
                const jsonRegex = /(\{(?:[^{}]|(?:\{(?:[^{}]|(?:\{[^{}]*\}))*\}))*\})/;
                const match = cleanedContent.match(jsonRegex);
                if (match && match[1]) cleanedContent = match[1];
            }
            cleanedContent = (0, external_jsonrepair_namespaceObject.jsonrepair)(cleanedContent);
            return JSON.parse(cleanedContent);
        } catch (e) {
            logger.warning(`Failed to parse model output: ${content} ${e}`);
            throw new Error('Could not parse response.');
        }
    }
    constructor(modelOutputSchema, options, extraOptions){
        _define_property(this, "id", void 0);
        _define_property(this, "chatLLM", void 0);
        _define_property(this, "prompt", void 0);
        _define_property(this, "context", void 0);
        _define_property(this, "actions", {});
        _define_property(this, "modelOutputSchema", void 0);
        _define_property(this, "toolCallingMethod", void 0);
        _define_property(this, "chatModelLibrary", void 0);
        _define_property(this, "modelName", void 0);
        _define_property(this, "withStructuredOutput", void 0);
        _define_property(this, "callOptions", void 0);
        _define_property(this, "modelOutputToolName", void 0);
        this.modelOutputSchema = modelOutputSchema;
        this.chatLLM = options.chatLLM;
        this.prompt = options.prompt;
        this.context = options.context;
        this.chatModelLibrary = this.chatLLM.constructor.name;
        this.modelName = this.setModelNames();
        this.withStructuredOutput = this.setWithStructuredOutput();
        this.id = (null == extraOptions ? void 0 : extraOptions.id) || 'agent';
        this.toolCallingMethod = this.setToolCallingMethod(null == extraOptions ? void 0 : extraOptions.toolCallingMethod);
        this.callOptions = null == extraOptions ? void 0 : extraOptions.callOptions;
        this.modelOutputToolName = `${this.id}_output`;
    }
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

//# sourceMappingURL=base.js.map