{"version":3,"file":"agent/agents/navigator.js","sources":["webpack://@agent-infra/browser-use/./src/agent/agents/navigator.ts"],"sourcesContent":["/**\n * The following code is modified based on\n * https://github.com/nanobrowser/nanobrowser/blob/master/chrome-extension/src/background/agent/agents/navigator.ts\n *\n * Apache-2.0 License\n * Copyright (c) 2024 alexchenzl\n * https://github.com/nanobrowser/nanobrowser/blob/master/LICENSE\n */\nimport { z } from 'zod';\nimport {\n  BaseAgent,\n  type BaseAgentOptions,\n  type ExtraAgentOptions,\n} from './base';\nimport { ActionResult, type AgentOutput } from '../types';\nimport type { Action } from '../actions/builder';\nimport { buildDynamicActionSchema } from '../actions/builder';\nimport { agentBrainSchema } from '../types';\nimport { type BaseMessage, HumanMessage } from '@langchain/core/messages';\nimport { Actors, ExecutionState } from '../event/types';\nimport { isAuthenticationError, createLogger } from '../../utils';\nimport { ChatModelAuthError } from './errors';\nimport { jsonNavigatorOutputSchema } from '../actions/json_schema';\nimport { geminiNavigatorOutputSchema } from '../actions/json_gemini';\nimport { jsonrepair } from 'jsonrepair';\nconst logger = createLogger('NavigatorAgent');\n\nexport class NavigatorActionRegistry {\n  private actions: Record<string, Action> = {};\n\n  constructor(actions: Action[]) {\n    for (const action of actions) {\n      this.registerAction(action);\n    }\n  }\n\n  registerAction(action: Action): void {\n    this.actions[action.name()] = action;\n  }\n\n  unregisterAction(name: string): void {\n    delete this.actions[name];\n  }\n\n  getAction(name: string): Action | undefined {\n    return this.actions[name];\n  }\n\n  setupModelOutputSchema(): z.ZodType {\n    const actionSchema = buildDynamicActionSchema(Object.values(this.actions));\n    return z.object({\n      current_state: agentBrainSchema,\n      action: z.array(actionSchema),\n    });\n  }\n}\n\nexport interface NavigatorResult {\n  done: boolean;\n}\n\nexport class NavigatorAgent extends BaseAgent<z.ZodType, NavigatorResult> {\n  private actionRegistry: NavigatorActionRegistry;\n\n  constructor(\n    actionRegistry: NavigatorActionRegistry,\n    options: BaseAgentOptions,\n    extraOptions?: Partial<ExtraAgentOptions>,\n  ) {\n    super(actionRegistry.setupModelOutputSchema(), options, {\n      ...extraOptions,\n      id: 'navigator',\n    });\n\n    this.actionRegistry = actionRegistry;\n  }\n\n  async invoke(inputMessages: BaseMessage[]): Promise<this['ModelOutput']> {\n    logger.info('invoke this.chatLLM', this.withStructuredOutput);\n    // Use structured output\n    if (this.withStructuredOutput) {\n      // For Google Generative AI, we need to use the modelOutputSchema directly\n      // but make sure it doesn't have any 'default' properties that cause issues\n\n      const schema =\n        this.chatModelLibrary === 'ChatGoogleGenerativeAI'\n          ? geminiNavigatorOutputSchema\n          : jsonNavigatorOutputSchema;\n\n      // TODO: don't know why zod can not generate the same schema. Use the json schema exported from browser-use as a workaround for now, need to fix it\n      const structuredLlm = this.chatLLM.withStructuredOutput(schema, {\n        includeRaw: true,\n      });\n\n      console.log('structuredLlm', structuredLlm);\n\n      const response = await structuredLlm.invoke(inputMessages, {\n        ...this.callOptions,\n      });\n      logger.info('invoke structuredLlm response', response);\n\n      if (response.parsed) {\n        return response.parsed;\n      } else {\n        return response.raw;\n      }\n      // throw new Error('Could not parse response');\n    }\n\n    // Without structured output support, need to extract JSON from model output manually\n    const response = await this.chatLLM.invoke(inputMessages, {\n      ...this.callOptions,\n    });\n    logger.info('invoke response', response);\n    if (typeof response.content === 'string') {\n      response.content = this.removeThinkTags(response.content);\n      try {\n        const extractedJson = this.extractJsonFromModelOutput(response.content);\n        const parsed = this.validateModelOutput(extractedJson);\n        if (parsed) {\n          return parsed;\n        }\n      } catch (error) {\n        logger.error('Could not parse response', response);\n        throw new Error('Could not parse response');\n      }\n    }\n    throw new Error('Could not parse response');\n  }\n\n  async execute(): Promise<AgentOutput<NavigatorResult>> {\n    const agentOutput: AgentOutput<NavigatorResult> = {\n      id: this.id,\n    };\n\n    let cancelled = false;\n\n    try {\n      this.context.emitEvent(\n        Actors.NAVIGATOR,\n        ExecutionState.STEP_START,\n        'Navigating...',\n      );\n\n      const messageManager = this.context.messageManager;\n      // add the browser state message\n      await this.addStateMessageToMemory();\n      // check if the task is paused or stopped\n      if (this.context.paused || this.context.stopped) {\n        cancelled = true;\n        return agentOutput;\n      }\n\n      // call the model to get the actions to take\n      const inputMessages = messageManager.getMessages();\n      const modelOutput = await this.invoke(inputMessages);\n      logger.info('modelOutput', modelOutput);\n\n      // check if the task is paused or stopped\n      if (this.context.paused || this.context.stopped) {\n        cancelled = true;\n        return agentOutput;\n      }\n      // remove the last state message from memory before adding the model output\n      this.removeLastStateMessageFromMemory();\n      this.addModelOutputToMemory(modelOutput);\n\n      logger.info('modelOutput.action', modelOutput.action);\n\n      // take the actions\n      const actionResults = await this.doMultiAction(modelOutput);\n      logger.info('actionResults', actionResults);\n      this.context.actionResults = actionResults;\n\n      // check if the task is paused or stopped\n      if (this.context.paused || this.context.stopped) {\n        cancelled = true;\n        return agentOutput;\n      }\n      // emit event\n      this.context.emitEvent(\n        Actors.NAVIGATOR,\n        ExecutionState.STEP_OK,\n        'Navigation done',\n      );\n      let done = false;\n      if (\n        actionResults.length > 0 &&\n        actionResults[actionResults.length - 1].isDone\n      ) {\n        done = true;\n      }\n      agentOutput.result = { done };\n      return agentOutput;\n    } catch (error) {\n      logger.error('execute error', error);\n      this.removeLastStateMessageFromMemory();\n      // Check if this is an authentication error\n      if (isAuthenticationError(error)) {\n        throw new ChatModelAuthError(\n          'Navigator API Authentication failed. Please verify your API key',\n          error,\n        );\n      }\n\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      const errorString = `Navigation failed: ${errorMessage}`;\n      logger.error(errorString);\n      this.context.emitEvent(\n        Actors.NAVIGATOR,\n        ExecutionState.STEP_FAIL,\n        errorString,\n      );\n      agentOutput.error = errorMessage;\n      return agentOutput;\n    } finally {\n      // if the task is cancelled, remove the last state message from memory and emit event\n      if (cancelled) {\n        this.removeLastStateMessageFromMemory();\n        this.context.emitEvent(\n          Actors.NAVIGATOR,\n          ExecutionState.STEP_CANCEL,\n          'Navigation cancelled',\n        );\n      }\n    }\n  }\n\n  /**\n   * Add the state message to the memory\n   */\n  public async addStateMessageToMemory() {\n    if (this.context.stateMessageAdded) {\n      return;\n    }\n\n    const messageManager = this.context.messageManager;\n    const options = this.context.options;\n    // Handle results that should be included in memory\n    if (this.context.actionResults.length > 0) {\n      let index = 0;\n      for (const r of this.context.actionResults) {\n        if (r.includeInMemory) {\n          if (r.extractedContent) {\n            const msg = new HumanMessage(\n              `Action result: ${r.extractedContent}`,\n            );\n            // logger.info('Adding action result to memory', msg.content);\n            messageManager.addMessageWithTokens(msg);\n          }\n          if (r.error) {\n            const msg = new HumanMessage(\n              `Action error: ${r.error.toString().slice(-options.maxErrorLength)}`,\n            );\n            logger.info('Adding action error to memory', msg.content);\n            messageManager.addMessageWithTokens(msg);\n          }\n          // reset this action result to empty, we dont want to add it again in the state message\n          this.context.actionResults[index] = new ActionResult();\n        }\n        index++;\n      }\n    }\n\n    const state = await this.prompt.getUserMessage(this.context);\n    messageManager.addStateMessage(state);\n    this.context.stateMessageAdded = true;\n  }\n\n  /**\n   * Remove the last state message from the memory\n   */\n  protected async removeLastStateMessageFromMemory() {\n    if (!this.context.stateMessageAdded) return;\n    const messageManager = this.context.messageManager;\n    messageManager.removeLastStateMessage();\n    this.context.stateMessageAdded = false;\n  }\n\n  private async doMultiAction(\n    response: this['ModelOutput'],\n  ): Promise<ActionResult[]> {\n    const results: ActionResult[] = [];\n    let errCount = 0;\n\n    logger.info('doMultiAction_Actions', response.action);\n    // sometimes response.action is a string, but not an array as expected, so we need to parse it as an array\n    let actions: Record<string, unknown>[] = [];\n    if (Array.isArray(response.action)) {\n      // if the item is null, skip it\n      actions = response.action.filter((item: unknown) => item !== null);\n      if (actions.length === 0) {\n        logger.warning('No valid actions found', response.action);\n      }\n    } else if (typeof response.action === 'string') {\n      try {\n        logger.warning('Unexpected action format', response.action);\n        const repaired = jsonrepair(response.action);\n        // try to parse the action as an JSON object\n        actions = JSON.parse(repaired);\n      } catch (error) {\n        logger.error('Invalid action format', response.action);\n        throw new Error('Invalid action output format');\n      }\n    } else {\n      // if the action is neither an array nor a string, it should be an object\n      actions = [response.action];\n    }\n\n    for (const action of actions) {\n      const actionName = Object.keys(action)[0];\n      const actionArgs = action[actionName];\n      try {\n        // check if the task is paused or stopped\n        if (this.context.paused || this.context.stopped) {\n          return results;\n        }\n\n        const result = await this.actionRegistry\n          .getAction(actionName)\n          ?.call(actionArgs);\n        if (result === undefined) {\n          throw new Error(\n            `Action ${actionName} not exists or returned undefined`,\n          );\n        }\n        results.push(result);\n        // check if the task is paused or stopped\n        if (this.context.paused || this.context.stopped) {\n          return results;\n        }\n        // TODO: wait for 1 second for now, need to optimize this to avoid unnecessary waiting\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : String(error);\n        logger.error('doAction error', errorMessage);\n        // unexpected error, emit event\n        this.context.emitEvent(\n          Actors.NAVIGATOR,\n          ExecutionState.ACT_FAIL,\n          errorMessage,\n        );\n        errCount++;\n        if (errCount > 3) {\n          throw new Error('Too many errors in actions');\n        }\n        results.push(\n          new ActionResult({\n            error: errorMessage,\n            isDone: false,\n            includeInMemory: true,\n          }),\n        );\n      }\n    }\n    return results;\n  }\n}\n"],"names":["logger","createLogger","NavigatorActionRegistry","action","name","actionSchema","buildDynamicActionSchema","Object","z","agentBrainSchema","actions","NavigatorAgent","BaseAgent","inputMessages","schema","geminiNavigatorOutputSchema","jsonNavigatorOutputSchema","structuredLlm","console","response","extractedJson","parsed","error","Error","agentOutput","cancelled","Actors","ExecutionState","messageManager","modelOutput","actionResults","done","isAuthenticationError","ChatModelAuthError","errorMessage","String","errorString","options","index","r","msg","HumanMessage","ActionResult","state","results","errCount","Array","item","repaired","jsonrepair","JSON","actionName","actionArgs","_this_actionRegistry_getAction","result","undefined","Promise","resolve","setTimeout","actionRegistry","extraOptions"],"mappings":"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"}