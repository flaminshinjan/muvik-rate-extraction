/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    Executor: ()=>Executor
});
const external_types_js_namespaceObject = require("./types.js");
const navigator_js_namespaceObject = require("./agents/navigator.js");
const planner_js_namespaceObject = require("./agents/planner.js");
const validator_js_namespaceObject = require("./agents/validator.js");
const external_prompts_navigator_js_namespaceObject = require("./prompts/navigator.js");
const external_prompts_planner_js_namespaceObject = require("./prompts/planner.js");
const external_prompts_validator_js_namespaceObject = require("./prompts/validator.js");
const external_utils_js_namespaceObject = require("../utils.js");
const service_js_namespaceObject = require("./messages/service.js");
var service_js_default = /*#__PURE__*/ __webpack_require__.n(service_js_namespaceObject);
const builder_js_namespaceObject = require("./actions/builder.js");
const manager_js_namespaceObject = require("./event/manager.js");
const types_js_namespaceObject = require("./event/types.js");
const errors_js_namespaceObject = require("./agents/errors.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, external_utils_js_namespaceObject.createLogger)('Executor');
class Executor {
    subscribeExecutionEvents(callback) {
        this.context.eventManager.subscribe(types_js_namespaceObject.EventType.EXECUTION, callback);
    }
    clearExecutionEvents() {
        this.context.eventManager.clearSubscribers(types_js_namespaceObject.EventType.EXECUTION);
    }
    addFollowUpTask(task) {
        this.tasks.push(task);
        this.context.messageManager.addNewTask(task);
        this.validatorPrompt.addFollowUpTask(task);
        this.context.actionResults = this.context.actionResults.filter((result)=>result.includeInMemory);
    }
    async execute() {
        logger.info(`ðŸš€ Executing task: ${this.tasks[this.tasks.length - 1]}`);
        const context = this.context;
        context.nSteps = 0;
        const allowedMaxSteps = this.context.options.maxSteps;
        const browserState = await this.context.browserContext.getState();
        try {
            this.context.emitEvent(types_js_namespaceObject.Actors.SYSTEM, types_js_namespaceObject.ExecutionState.TASK_START, this.context.taskId, browserState);
            let done = false;
            let step = 0;
            let validatorFailed = false;
            for(step = 0; step < allowedMaxSteps; step++){
                context.stepInfo = {
                    stepNumber: context.nSteps,
                    maxSteps: context.options.maxSteps
                };
                logger.info(`ðŸ”„ Step ${step + 1} / ${allowedMaxSteps}`);
                if (await this.shouldStop()) break;
                if (this.planner && (context.nSteps % context.options.planningInterval === 0 || validatorFailed)) {
                    validatorFailed = false;
                    if (this.tasks.length > 1 || step > 0) await this.navigator.addStateMessageToMemory();
                    const planOutput = await this.planner.execute();
                    if (planOutput.result) {
                        logger.info(`ðŸ”„ Planner output: ${JSON.stringify(planOutput.result, null, 2)}`);
                        this.context.messageManager.addPlan(JSON.stringify(planOutput.result), this.context.messageManager.length() - 1);
                        if (planOutput.result.done) {
                            done = true;
                            this.validator.setPlan(planOutput.result.next_steps);
                        } else {
                            this.validator.setPlan(null);
                            done = false;
                        }
                        if (!planOutput.result.web_task && planOutput.result.done) break;
                    }
                }
                if (!done) done = await this.navigate();
                if (done && this.context.options.validateOutput && !this.context.stopped && !this.context.paused) {
                    var _validatorOutput_result;
                    const validatorOutput = await this.validator.execute();
                    if (null === (_validatorOutput_result = validatorOutput.result) || void 0 === _validatorOutput_result ? void 0 : _validatorOutput_result.is_valid) {
                        logger.info('âœ… Task completed successfully');
                        break;
                    }
                    validatorFailed = true;
                }
            }
            if (done) this.context.emitEvent(types_js_namespaceObject.Actors.SYSTEM, types_js_namespaceObject.ExecutionState.TASK_OK, this.context.taskId, browserState);
            else if (step >= allowedMaxSteps) {
                logger.info('âŒ Task failed: Max steps reached');
                this.context.emitEvent(types_js_namespaceObject.Actors.SYSTEM, types_js_namespaceObject.ExecutionState.TASK_FAIL, 'Task failed: Max steps reached', browserState);
            } else if (this.context.stopped) this.context.emitEvent(types_js_namespaceObject.Actors.SYSTEM, types_js_namespaceObject.ExecutionState.TASK_CANCEL, 'Task cancelled', browserState);
            else this.context.emitEvent(types_js_namespaceObject.Actors.SYSTEM, types_js_namespaceObject.ExecutionState.TASK_PAUSE, 'Task paused', browserState);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.context.emitEvent(types_js_namespaceObject.Actors.SYSTEM, types_js_namespaceObject.ExecutionState.TASK_FAIL, `Task failed: ${errorMessage}`, browserState);
        }
    }
    async navigate() {
        const context = this.context;
        try {
            var _navOutput_result;
            if (context.paused || context.stopped) return false;
            const navOutput = await this.navigator.execute();
            if (context.paused || context.stopped) return false;
            context.nSteps++;
            if (navOutput.error) throw new Error(navOutput.error);
            context.consecutiveFailures = 0;
            if (null === (_navOutput_result = navOutput.result) || void 0 === _navOutput_result ? void 0 : _navOutput_result.done) return true;
        } catch (error) {
            if (error instanceof errors_js_namespaceObject.ChatModelAuthError) throw error;
            context.consecutiveFailures++;
            logger.error(`Failed to execute step: ${error}`);
            if (context.consecutiveFailures >= context.options.maxFailures) throw new Error('Max failures reached');
        }
        return false;
    }
    async shouldStop() {
        if (this.context.stopped) {
            logger.info('Agent stopped');
            return true;
        }
        while(this.context.paused){
            await new Promise((resolve)=>setTimeout(resolve, 200));
            if (this.context.stopped) return true;
        }
        if (this.context.consecutiveFailures >= this.context.options.maxFailures) {
            logger.error(`Stopping due to ${this.context.options.maxFailures} consecutive failures`);
            return true;
        }
        return false;
    }
    async cancel() {
        this.context.stop();
    }
    async resume() {
        this.context.resume();
    }
    async pause() {
        this.context.pause();
    }
    async cleanup() {
        try {
            await this.context.browserContext.cleanup();
        } catch (error) {
            logger.error(`Failed to cleanup browser context: ${error}`);
        }
    }
    async getCurrentTaskId() {
        return this.context.taskId;
    }
    constructor(task, taskId, browserContext, navigatorLLM, extraArgs){
        _define_property(this, "navigator", void 0);
        _define_property(this, "planner", void 0);
        _define_property(this, "validator", void 0);
        _define_property(this, "context", void 0);
        _define_property(this, "plannerPrompt", void 0);
        _define_property(this, "navigatorPrompt", void 0);
        _define_property(this, "validatorPrompt", void 0);
        _define_property(this, "tasks", []);
        const messageManager = new (service_js_default())({});
        const plannerLLM = (null == extraArgs ? void 0 : extraArgs.plannerLLM) ?? navigatorLLM;
        const validatorLLM = (null == extraArgs ? void 0 : extraArgs.validatorLLM) ?? navigatorLLM;
        const extractorLLM = (null == extraArgs ? void 0 : extraArgs.extractorLLM) ?? navigatorLLM;
        const eventManager = new manager_js_namespaceObject.EventManager();
        const context = new external_types_js_namespaceObject.AgentContext(taskId, browserContext, messageManager, eventManager, (null == extraArgs ? void 0 : extraArgs.agentOptions) ?? {});
        this.tasks.push(task);
        this.navigatorPrompt = new external_prompts_navigator_js_namespaceObject.NavigatorPrompt(context.options.maxActionsPerStep);
        this.plannerPrompt = new external_prompts_planner_js_namespaceObject.PlannerPrompt();
        this.validatorPrompt = new external_prompts_validator_js_namespaceObject.ValidatorPrompt(task);
        const actionBuilder = new builder_js_namespaceObject.ActionBuilder(context, extractorLLM);
        const navigatorActionRegistry = new navigator_js_namespaceObject.NavigatorActionRegistry(actionBuilder.buildDefaultActions());
        this.navigator = new navigator_js_namespaceObject.NavigatorAgent(navigatorActionRegistry, {
            chatLLM: navigatorLLM,
            context: context,
            prompt: this.navigatorPrompt
        });
        this.planner = new planner_js_namespaceObject.PlannerAgent({
            chatLLM: plannerLLM,
            context: context,
            prompt: this.plannerPrompt
        });
        this.validator = new validator_js_namespaceObject.ValidatorAgent({
            chatLLM: validatorLLM,
            context: context,
            prompt: this.validatorPrompt
        });
        this.context = context;
        this.context.messageManager.initTaskMessages(this.navigatorPrompt.getSystemMessage(), task);
    }
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

//# sourceMappingURL=executor.js.map