{"version":3,"file":"browser/page.mjs","sources":["webpack://@agent-infra/browser-use/./src/browser/page.ts"],"sourcesContent":["/**\n * The following code is modified based on\n * https://github.com/nanobrowser/nanobrowser/blob/master/chrome-extension/src/background/browser/page.ts\n *\n * Apache-2.0 License\n * Copyright (c) 2024 alexchenzl\n * https://github.com/nanobrowser/nanobrowser/blob/master/LICENSE\n */\nimport {\n  type HTTPRequest,\n  type HTTPResponse,\n  type KeyInput,\n} from 'puppeteer-core/lib/esm/puppeteer/puppeteer-core-browser.js';\nimport { LocalBrowser } from '@agent-infra/browser';\nimport {\n  Browser,\n  Page as PuppeteerPage,\n  ElementHandle,\n  Frame,\n} from 'puppeteer-core';\nimport {\n  getClickableElements as _getClickableElements,\n  removeHighlights as _removeHighlights,\n  getScrollInfo as _getScrollInfo,\n  getMarkdownContent as _getMarkdownContent,\n  getReadabilityContent as _getReadabilityContent,\n  ReadabilityResult,\n} from '../dom/service';\nimport { DOMElementNode, type DOMState } from '../dom/views';\nimport {\n  type BrowserContextConfig,\n  DEFAULT_BROWSER_CONTEXT_CONFIG,\n  type PageState,\n} from './types';\nimport { createLogger, getBuildDomTreeScript } from '../utils';\nimport {\n  locateElement,\n  scrollIntoViewIfNeeded,\n  waitForPageAndFramesLoad,\n} from './utils';\n\nconst logger = createLogger('Page');\n\ndeclare global {\n  interface Window {\n    turn2Markdown: (selector?: string) => string;\n  }\n}\n\nexport function build_initial_state(url?: string, title?: string): PageState {\n  return {\n    elementTree: new DOMElementNode({\n      tagName: 'root',\n      isVisible: true,\n      parent: null,\n      xpath: '',\n      cssSelector: '',\n      attributes: {},\n      children: [],\n    }),\n    selectorMap: new Map(),\n    tabId: 0,\n    url: url || '',\n    title: title || '',\n    screenshot: null,\n    pixelsAbove: 0,\n    pixelsBelow: 0,\n  };\n}\n\nexport default class Page {\n  private _browser: Browser | null = null;\n  private _puppeteerPage: PuppeteerPage | null = null;\n  private _config: BrowserContextConfig;\n  private _state: PageState;\n  private _validWebPage = false;\n\n  constructor(\n    url: string,\n    title: string,\n    config: Partial<BrowserContextConfig> = {},\n  ) {\n    this._config = { ...DEFAULT_BROWSER_CONTEXT_CONFIG, ...config };\n    this._state = build_initial_state(url, title);\n    // chrome://newtab/, chrome://newtab/extensions are not valid web pages, can't be attached\n    this._validWebPage = (url && url.startsWith('http')) || false;\n  }\n\n  get browser(): Browser | null {\n    return this._browser;\n  }\n\n  get puppeteerPage(): PuppeteerPage | null {\n    return this._puppeteerPage;\n  }\n\n  get validWebPage(): boolean {\n    return this._validWebPage;\n  }\n\n  get attached(): boolean {\n    return this._validWebPage && this._puppeteerPage !== null;\n  }\n\n  async executeScript(\n    page: PuppeteerPage,\n    options: {\n      contents?: string[];\n    },\n  ): Promise<any> {\n    if (!page) {\n      throw new Error('Puppeteer页面未连接');\n    }\n\n    if (options.contents && options.contents.length > 0) {\n      for (const content of options.contents) {\n        await page.evaluateOnNewDocument(content);\n        logger.info(`已注入脚本文件`);\n      }\n    }\n  }\n\n  async attachPuppeteer(): Promise<boolean> {\n    if (!this._validWebPage) {\n      return false;\n    }\n\n    if (this._puppeteerPage) {\n      return true;\n    }\n\n    logger.info('attaching puppeteer');\n    // const browser = await connect({\n    //   transport: await ExtensionTransport.connectTab(this._tabId),\n    //   defaultViewport: null,\n    //   protocol: 'cdp' as ProtocolType,\n    // });\n    const localBrowser = new LocalBrowser();\n    await localBrowser.launch();\n\n    const browser = await localBrowser.getBrowser();\n\n    this._browser = browser;\n\n    const [page] = await browser.pages();\n\n    await this.executeScript(page, {\n      contents: [getBuildDomTreeScript()],\n    });\n\n    await page.goto(this._state.url);\n    this._puppeteerPage = page;\n\n    // Add anti-detection scripts\n    await this._addAntiDetectionScripts();\n\n    return true;\n  }\n\n  private async _addAntiDetectionScripts(): Promise<void> {\n    if (!this._puppeteerPage) {\n      return;\n    }\n\n    await this._puppeteerPage.evaluateOnNewDocument(`\n      // Webdriver property\n      Object.defineProperty(navigator, 'webdriver', {\n        get: () => undefined\n      });\n\n      // Languages\n      // Object.defineProperty(navigator, 'languages', {\n      //   get: () => ['en-US', 'zh-CN']\n      // });\n\n      // Plugins\n      // Object.defineProperty(navigator, 'plugins', {\n      //   get: () => [1, 2, 3, 4, 5]\n      // });\n\n      // Chrome runtime\n      window.chrome = { runtime: {} };\n\n      // Permissions\n      const originalQuery = window.navigator.permissions.query;\n      window.navigator.permissions.query = (parameters) => (\n        parameters.name === 'notifications' ?\n          Promise.resolve({ state: Notification.permission }) :\n          originalQuery(parameters)\n      );\n\n      // Shadow DOM\n      (function () {\n        const originalAttachShadow = Element.prototype.attachShadow;\n        Element.prototype.attachShadow = function attachShadow(options) {\n          return originalAttachShadow.call(this, { ...options, mode: \"open\" });\n        };\n      })();\n    `);\n  }\n\n  async detachPuppeteer(): Promise<void> {\n    if (this._browser) {\n      await this._browser.disconnect();\n      this._browser = null;\n      this._puppeteerPage = null;\n      // reset the state\n      this._state = build_initial_state();\n    }\n  }\n\n  async removeHighlight(): Promise<void> {\n    if (this._config.highlightElements && this._validWebPage) {\n      await _removeHighlights(this._puppeteerPage!);\n    }\n  }\n\n  async getClickableElements(focusElement: number): Promise<DOMState | null> {\n    if (!this._validWebPage) {\n      return null;\n    }\n    return _getClickableElements(\n      this._puppeteerPage!,\n      this._config.highlightElements,\n      focusElement,\n      this._config.viewportExpansion,\n    );\n  }\n\n  // Get scroll position information for the current page.\n  async getScrollInfo(): Promise<[number, number]> {\n    if (!this._validWebPage) {\n      return [0, 0];\n    }\n    return _getScrollInfo(this._puppeteerPage!);\n  }\n\n  async getContent(): Promise<string> {\n    if (!this._puppeteerPage) {\n      throw new Error('Puppeteer page is not connected');\n    }\n    return await this._puppeteerPage.content();\n  }\n\n  async getMarkdownContent(selector?: string): Promise<string> {\n    if (!this._validWebPage) {\n      return '';\n    }\n    return _getMarkdownContent(this._puppeteerPage!, selector);\n  }\n\n  async getReadabilityContent(): Promise<ReadabilityResult | null> {\n    if (!this._validWebPage) {\n      return null;\n    }\n    return _getReadabilityContent(this._puppeteerPage!);\n  }\n\n  async getState(): Promise<PageState> {\n    if (!this._validWebPage) {\n      // return the initial state\n      return build_initial_state();\n    }\n    await this.waitForPageAndFramesLoad();\n    const state = await this._updateState();\n    return state;\n  }\n\n  async _updateState(useVision = true, focusElement = -1): Promise<PageState> {\n    try {\n      // Test if page is still accessible\n      // @ts-expect-error - puppeteerPage is not null, already checked before calling this function\n      await this._puppeteerPage.evaluate('1');\n    } catch (error) {\n      logger.warning('Current page is no longer accessible:', error);\n      if (this._browser) {\n        const pages = await this._browser.pages();\n        if (pages.length > 0) {\n          this._puppeteerPage = pages[0];\n        } else {\n          throw new Error('Browser closed: no valid pages available');\n        }\n      }\n    }\n\n    try {\n      await this.removeHighlight();\n\n      // Get DOM content (equivalent to dom_service.get_clickable_elements)\n      // This part would need to be implemented based on your DomService logic\n      const content = await this.getClickableElements(focusElement);\n      if (!content) {\n        logger.warning('Failed to get clickable elements');\n        // Return last known good state if available\n        return this._state;\n      }\n      // log the attributes of content object\n      if ('selectorMap' in content) {\n        logger.debug('content.selectorMap:', content.selectorMap.size);\n      } else {\n        logger.debug('content.selectorMap: not found');\n      }\n      if ('elementTree' in content) {\n        logger.debug('content.elementTree:', content.elementTree?.tagName);\n      } else {\n        logger.debug('content.elementTree: not found');\n      }\n\n      // Take screenshot if needed\n      const screenshot = useVision ? await this.takeScreenshot() : null;\n      const [pixelsAbove, pixelsBelow] = await this.getScrollInfo();\n\n      // update the state\n      this._state.elementTree = content.elementTree;\n      this._state.selectorMap = content.selectorMap;\n      this._state.url = this._puppeteerPage?.url() || '';\n      this._state.title = (await this._puppeteerPage?.title()) || '';\n      this._state.screenshot = screenshot;\n      this._state.pixelsAbove = pixelsAbove;\n      this._state.pixelsBelow = pixelsBelow;\n      return this._state;\n    } catch (error) {\n      logger.error('Failed to update state:', error);\n      // Return last known good state if available\n      return this._state;\n    }\n  }\n\n  async takeScreenshot(fullPage = false): Promise<string | null> {\n    if (!this._puppeteerPage) {\n      throw new Error('Puppeteer page is not connected');\n    }\n\n    try {\n      // First disable animations/transitions\n      await this._puppeteerPage.evaluate(() => {\n        const styleId = 'puppeteer-disable-animations';\n        if (!document.getElementById(styleId)) {\n          const style = document.createElement('style');\n          style.id = styleId;\n          style.textContent = `\n            *, *::before, *::after {\n              animation: none !important;\n              transition: none !important;\n            }\n          `;\n          document.head.appendChild(style);\n        }\n      });\n\n      // Take the screenshot using JPEG format with 80% quality\n      const screenshot = await this._puppeteerPage.screenshot({\n        fullPage: fullPage,\n        encoding: 'base64',\n        type: 'jpeg',\n        quality: 80, // Good balance between quality and file size\n      });\n\n      // Clean up the style element\n      await this._puppeteerPage.evaluate(() => {\n        const style = document.getElementById('puppeteer-disable-animations');\n        if (style) {\n          style.remove();\n        }\n      });\n\n      return screenshot as string;\n    } catch (error) {\n      logger.error('Failed to take screenshot:', error);\n      throw error;\n    }\n  }\n\n  url(): string {\n    if (this._puppeteerPage) {\n      return this._puppeteerPage.url();\n    }\n    return this._state.url;\n  }\n\n  async title(): Promise<string> {\n    if (this._puppeteerPage) {\n      return await this._puppeteerPage.title();\n    }\n    return this._state.title;\n  }\n\n  async navigateTo(url: string): Promise<void> {\n    if (!this._puppeteerPage) {\n      return;\n    }\n    logger.info('navigateTo', url);\n\n    try {\n      await Promise.all([\n        this.waitForPageAndFramesLoad(),\n        this._puppeteerPage.goto(url),\n      ]);\n      logger.info('navigateTo complete');\n    } catch (error) {\n      // Check if it's a timeout error\n      if (error instanceof Error && error.message.includes('timeout')) {\n        logger.warning(\n          'Navigation timeout, but page might still be usable:',\n          error,\n        );\n        // You might want to check if the page is actually loaded despite the timeout\n      } else {\n        logger.error('NavigationTo failed:', error);\n        throw error; // Re-throw non-timeout errors\n      }\n    }\n  }\n\n  async refreshPage(): Promise<void> {\n    if (!this._puppeteerPage) return;\n\n    try {\n      await Promise.all([\n        this.waitForPageAndFramesLoad(),\n        this._puppeteerPage.reload(),\n      ]);\n      logger.info('Page refresh complete');\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('timeout')) {\n        logger.warning(\n          'Refresh timeout, but page might still be usable:',\n          error,\n        );\n      } else {\n        logger.error('Page refresh failed:', error);\n        throw error;\n      }\n    }\n  }\n\n  async goBack(): Promise<void> {\n    if (!this._puppeteerPage) return;\n\n    try {\n      await Promise.all([\n        this.waitForPageAndFramesLoad(),\n        this._puppeteerPage.goBack(),\n      ]);\n      logger.info('Navigation back completed');\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('timeout')) {\n        logger.warning(\n          'Back navigation timeout, but page might still be usable:',\n          error,\n        );\n      } else {\n        logger.error('Could not navigate back:', error);\n        throw error;\n      }\n    }\n  }\n\n  async goForward(): Promise<void> {\n    if (!this._puppeteerPage) return;\n\n    try {\n      await Promise.all([\n        this.waitForPageAndFramesLoad(),\n        this._puppeteerPage.goForward(),\n      ]);\n      logger.info('Navigation forward completed');\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('timeout')) {\n        logger.warning(\n          'Forward navigation timeout, but page might still be usable:',\n          error,\n        );\n      } else {\n        logger.error('Could not navigate forward:', error);\n        throw error;\n      }\n    }\n  }\n\n  async scrollDown(amount?: number): Promise<void> {\n    if (this._puppeteerPage) {\n      if (amount) {\n        await this._puppeteerPage?.evaluate(`window.scrollBy(0, ${amount});`);\n      } else {\n        await this._puppeteerPage?.evaluate(\n          'window.scrollBy(0, window.innerHeight);',\n        );\n      }\n    }\n  }\n\n  async scrollUp(amount?: number): Promise<void> {\n    if (this._puppeteerPage) {\n      if (amount) {\n        await this._puppeteerPage?.evaluate(`window.scrollBy(0, -${amount});`);\n      } else {\n        await this._puppeteerPage?.evaluate(\n          'window.scrollBy(0, -window.innerHeight);',\n        );\n      }\n    }\n  }\n\n  async sendKeys(keys: string): Promise<void> {\n    if (!this._puppeteerPage) {\n      throw new Error('Puppeteer page is not connected');\n    }\n\n    // Split combination keys (e.g., \"Control+A\" or \"Shift+ArrowLeft\")\n    const keyParts = keys.split('+');\n    const modifiers = keyParts.slice(0, -1);\n    const mainKey = keyParts[keyParts.length - 1];\n\n    // Press modifiers and main key, ensure modifiers are released even if an error occurs.\n    try {\n      // Press all modifier keys (e.g., Control, Shift, etc.)\n      for (const modifier of modifiers) {\n        await this._puppeteerPage.keyboard.down(this._convertKey(modifier));\n      }\n      // Press the main key\n      // also wait for stable state\n      await Promise.all([\n        this._puppeteerPage.keyboard.press(this._convertKey(mainKey)),\n        this.waitForPageAndFramesLoad(),\n      ]);\n      logger.info('sendKeys complete', keys);\n    } catch (error) {\n      logger.error('Failed to send keys:', error);\n      throw new Error(\n        `Failed to send keys: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    } finally {\n      // Release all modifier keys in reverse order regardless of any errors in key press.\n      for (const modifier of [...modifiers].reverse()) {\n        try {\n          await this._puppeteerPage.keyboard.up(this._convertKey(modifier));\n        } catch (releaseError) {\n          logger.error('Failed to release modifier:', modifier, releaseError);\n        }\n      }\n    }\n  }\n\n  private _convertKey(key: string): KeyInput {\n    const lowerKey = key.trim().toLowerCase();\n    const keyMap: { [key: string]: string } = {\n      // Letters\n      a: 'KeyA',\n      b: 'KeyB',\n      c: 'KeyC',\n      d: 'KeyD',\n      e: 'KeyE',\n      f: 'KeyF',\n      g: 'KeyG',\n      h: 'KeyH',\n      i: 'KeyI',\n      j: 'KeyJ',\n      k: 'KeyK',\n      l: 'KeyL',\n      m: 'KeyM',\n      n: 'KeyN',\n      o: 'KeyO',\n      p: 'KeyP',\n      q: 'KeyQ',\n      r: 'KeyR',\n      s: 'KeyS',\n      t: 'KeyT',\n      u: 'KeyU',\n      v: 'KeyV',\n      w: 'KeyW',\n      x: 'KeyX',\n      y: 'KeyY',\n      z: 'KeyZ',\n\n      // Numbers\n      '0': 'Digit0',\n      '1': 'Digit1',\n      '2': 'Digit2',\n      '3': 'Digit3',\n      '4': 'Digit4',\n      '5': 'Digit5',\n      '6': 'Digit6',\n      '7': 'Digit7',\n      '8': 'Digit8',\n      '9': 'Digit9',\n\n      // Special keys\n      control: 'Control',\n      shift: 'Shift',\n      alt: 'Alt',\n      meta: 'Meta',\n      enter: 'Enter',\n      backspace: 'Backspace',\n      delete: 'Delete',\n      arrowleft: 'ArrowLeft',\n      arrowright: 'ArrowRight',\n      arrowup: 'ArrowUp',\n      arrowdown: 'ArrowDown',\n      escape: 'Escape',\n      tab: 'Tab',\n      space: 'Space',\n    };\n\n    const convertedKey = keyMap[lowerKey] || key;\n    logger.info('convertedKey', convertedKey);\n    return convertedKey as KeyInput;\n  }\n\n  async scrollToText(text: string): Promise<boolean> {\n    if (!this._puppeteerPage) {\n      throw new Error('Puppeteer is not connected');\n    }\n\n    try {\n      // Try different locator strategies\n      const selectors = [\n        // Using text selector (equivalent to get_by_text)\n        `::-p-text(${text})`,\n        // Using XPath selector (contains text) - case insensitive\n        `::-p-xpath(//*[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '${text.toLowerCase()}')])`,\n      ];\n\n      for (const selector of selectors) {\n        try {\n          const element = await this._puppeteerPage.$(selector);\n          if (element) {\n            // Check if element is visible\n            const isVisible = await element.evaluate((el) => {\n              const style = window.getComputedStyle(el);\n              return (\n                style.display !== 'none' &&\n                style.visibility !== 'hidden' &&\n                style.opacity !== '0'\n              );\n            });\n\n            if (isVisible) {\n              await this._scrollIntoViewIfNeeded(element);\n              await new Promise((resolve) => setTimeout(resolve, 500)); // Wait for scroll to complete\n              return true;\n            }\n          }\n        } catch (e) {\n          logger.debug(`Locator attempt failed: ${e}`);\n        }\n      }\n      return false;\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : String(error));\n    }\n  }\n\n  async getDropdownOptions(\n    index: number,\n  ): Promise<Array<{ index: number; text: string; value: string }>> {\n    const selectorMap = this.getSelectorMap();\n    const element = selectorMap?.get(index);\n\n    if (!element || !this._puppeteerPage) {\n      throw new Error('Element not found or puppeteer is not connected');\n    }\n\n    try {\n      // Get the element handle using the element's selector\n      const elementHandle = await this.locateElement(element);\n      if (!elementHandle) {\n        throw new Error('Dropdown element not found');\n      }\n\n      // Evaluate the select element to get all options\n      const options = await elementHandle.evaluate((select) => {\n        if (!(select instanceof HTMLSelectElement)) {\n          throw new Error('Element is not a select element');\n        }\n\n        return Array.from(select.options).map((option) => ({\n          index: option.index,\n          text: option.text, // Not trimming to maintain exact match for selection\n          value: option.value,\n        }));\n      });\n\n      if (!options.length) {\n        throw new Error('No options found in dropdown');\n      }\n\n      return options;\n    } catch (error) {\n      throw new Error(\n        `Failed to get dropdown options: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  async selectDropdownOption(index: number, text: string): Promise<string> {\n    const selectorMap = this.getSelectorMap();\n    const element = selectorMap?.get(index);\n\n    if (!element || !this._puppeteerPage) {\n      throw new Error('Element not found or puppeteer is not connected');\n    }\n\n    logger.debug(`Attempting to select '${text}' from dropdown`);\n    logger.debug(`Element attributes: ${JSON.stringify(element.attributes)}`);\n    logger.debug(`Element tag: ${element.tagName}`);\n\n    // Validate that we're working with a select element\n    if (element.tagName?.toLowerCase() !== 'select') {\n      const msg = `Cannot select option: Element with index ${index} is a ${element.tagName}, not a SELECT`;\n      logger.error(msg);\n      throw new Error(msg);\n    }\n\n    try {\n      // Get the element handle using the element's selector\n      const elementHandle = await this.locateElement(element);\n      if (!elementHandle) {\n        throw new Error(`Dropdown element with index ${index} not found`);\n      }\n\n      // Verify dropdown and select option in one call\n      const result = await elementHandle.evaluate(\n        (select, optionText, elementIndex) => {\n          if (!(select instanceof HTMLSelectElement)) {\n            return {\n              found: false,\n              message: `Element with index ${elementIndex} is not a SELECT`,\n            };\n          }\n\n          const options = Array.from(select.options);\n          const option = options.find((opt) => opt.text.trim() === optionText);\n\n          if (!option) {\n            const availableOptions = options\n              .map((o) => o.text.trim())\n              .join('\", \"');\n            return {\n              found: false,\n              message: `Option \"${optionText}\" not found in dropdown element with index ${elementIndex}. Available options: \"${availableOptions}\"`,\n            };\n          }\n\n          // Set the value and dispatch events\n          const previousValue = select.value;\n          select.value = option.value;\n\n          // Only dispatch events if the value actually changed\n          if (previousValue !== option.value) {\n            select.dispatchEvent(new Event('change', { bubbles: true }));\n            select.dispatchEvent(new Event('input', { bubbles: true }));\n          }\n\n          return {\n            found: true,\n            message: `Selected option \"${optionText}\" with value \"${option.value}\"`,\n          };\n        },\n        text,\n        index,\n      );\n\n      logger.debug('Selection result:', result);\n      // whether found or not, return the message\n      return result.message;\n    } catch (error) {\n      const errorMessage = `${error instanceof Error ? error.message : String(error)}`;\n      logger.error(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }\n\n  async locateElement(element: DOMElementNode): Promise<ElementHandle | null> {\n    return await locateElement(this._puppeteerPage!, element, this._config);\n  }\n\n  async inputTextElementNode(\n    useVision: boolean,\n    elementNode: DOMElementNode,\n    text: string,\n  ): Promise<void> {\n    if (!this._puppeteerPage) {\n      throw new Error('Puppeteer is not connected');\n    }\n\n    try {\n      // Highlight before typing\n      if (elementNode.highlightIndex !== undefined) {\n        await this._updateState(useVision, elementNode.highlightIndex);\n      }\n\n      const element = await this.locateElement(elementNode);\n      if (!element) {\n        throw new Error(`Element: ${elementNode} not found`);\n      }\n\n      // Scroll element into view if needed\n      await this._scrollIntoViewIfNeeded(element);\n\n      // Clear the input field (equivalent to fill(''))\n      await element.evaluate((el) => {\n        if (\n          el instanceof HTMLInputElement ||\n          el instanceof HTMLTextAreaElement\n        ) {\n          el.value = '';\n          el.dispatchEvent(new Event('input', { bubbles: true }));\n          el.dispatchEvent(new Event('change', { bubbles: true }));\n        }\n      });\n\n      // Type the text\n      await element.type(text);\n      // Wait for stable state ?\n    } catch (error) {\n      throw new Error(\n        `Failed to input text into element: ${elementNode}. Error: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  private async _scrollIntoViewIfNeeded(\n    element: ElementHandle,\n    timeout = 2500,\n  ): Promise<void> {\n    await scrollIntoViewIfNeeded(element, timeout);\n  }\n\n  async clickElementNode(\n    useVision: boolean,\n    elementNode: DOMElementNode,\n  ): Promise<void> {\n    if (!this._puppeteerPage) {\n      throw new Error('Puppeteer is not connected');\n    }\n\n    try {\n      // Highlight before clicking\n      if (elementNode.highlightIndex !== undefined) {\n        await this._updateState(useVision, elementNode.highlightIndex);\n      }\n\n      const element = await this.locateElement(elementNode);\n      if (!element) {\n        throw new Error(`Element: ${elementNode} not found`);\n      }\n\n      // Scroll element into view if needed\n      await this._scrollIntoViewIfNeeded(element);\n\n      try {\n        // First attempt: Use Puppeteer's click method with timeout\n        await Promise.race([\n          element.click(),\n          new Promise((_, reject) =>\n            setTimeout(() => reject(new Error('Click timeout')), 2000),\n          ),\n        ]);\n      } catch (error) {\n        // Second attempt: Use evaluate to perform a direct click\n        logger.info('Failed to click element, trying again', error);\n        try {\n          await element.evaluate((el) => (el as HTMLElement).click());\n        } catch (secondError) {\n          throw new Error(\n            `Failed to click element: ${secondError instanceof Error ? secondError.message : String(secondError)}`,\n          );\n        }\n      }\n    } catch (error) {\n      throw new Error(\n        `Failed to click element: ${elementNode}. Error: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  getSelectorMap(): Map<number, DOMElementNode> {\n    return this._state.selectorMap;\n  }\n\n  async getElementByIndex(index: number): Promise<ElementHandle | null> {\n    const selectorMap = this.getSelectorMap();\n    const element = selectorMap.get(index);\n    if (!element) return null;\n    return await this.locateElement(element);\n  }\n\n  getDomElementByIndex(index: number): DOMElementNode | null {\n    const selectorMap = this.getSelectorMap();\n    return selectorMap.get(index) || null;\n  }\n\n  isFileUploader(\n    elementNode: DOMElementNode,\n    maxDepth = 3,\n    currentDepth = 0,\n  ): boolean {\n    if (currentDepth > maxDepth) {\n      return false;\n    }\n\n    // Check current element\n    if (elementNode.tagName === 'input') {\n      // Check for file input attributes\n      const attributes = elementNode.attributes;\n      // biome-ignore lint/complexity/useLiteralKeys: <explanation>\n      if (\n        attributes['type']?.toLowerCase() === 'file' ||\n        !!attributes['accept']\n      ) {\n        return true;\n      }\n    }\n\n    // Recursively check children\n    if (elementNode.children && currentDepth < maxDepth) {\n      for (const child of elementNode.children) {\n        if ('tagName' in child) {\n          // DOMElementNode type guard\n          if (\n            this.isFileUploader(\n              child as DOMElementNode,\n              maxDepth,\n              currentDepth + 1,\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  async waitForPageAndFramesLoad(timeoutOverwrite?: number): Promise<void> {\n    await waitForPageAndFramesLoad(\n      this._puppeteerPage,\n      timeoutOverwrite,\n      this._config,\n    );\n  }\n}\n"],"names":["logger","createLogger","build_initial_state","url","title","DOMElementNode","Map","Page","page","options","Error","content","localBrowser","LocalBrowser","browser","getBuildDomTreeScript","_removeHighlights","focusElement","_getClickableElements","_getScrollInfo","selector","_getMarkdownContent","_getReadabilityContent","state","useVision","error","pages","_this__puppeteerPage","_this__puppeteerPage1","_content_elementTree","screenshot","pixelsAbove","pixelsBelow","fullPage","styleId","document","style","Promise","amount","keys","keyParts","modifiers","mainKey","modifier","String","releaseError","key","lowerKey","keyMap","convertedKey","text","selectors","element","isVisible","el","window","resolve","setTimeout","e","index","selectorMap","elementHandle","select","HTMLSelectElement","Array","option","_element_tagName","JSON","msg","result","optionText","elementIndex","opt","availableOptions","o","previousValue","Event","errorMessage","locateElement","elementNode","undefined","HTMLInputElement","HTMLTextAreaElement","timeout","scrollIntoViewIfNeeded","_","reject","secondError","maxDepth","currentDepth","_attributes_type","attributes","child","timeoutOverwrite","waitForPageAndFramesLoad","config","DEFAULT_BROWSER_CONTEXT_CONFIG"],"mappings":"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"}