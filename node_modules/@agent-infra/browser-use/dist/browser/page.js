/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    build_initial_state: ()=>build_initial_state,
    default: ()=>Page
});
const browser_namespaceObject = require("@agent-infra/browser");
const service_js_namespaceObject = require("../dom/service.js");
const views_js_namespaceObject = require("../dom/views.js");
const external_types_js_namespaceObject = require("./types.js");
const external_utils_js_namespaceObject = require("../utils.js");
const external_utils_js_namespaceObject_1 = require("./utils.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, external_utils_js_namespaceObject.createLogger)('Page');
function build_initial_state(url, title) {
    return {
        elementTree: new views_js_namespaceObject.DOMElementNode({
            tagName: 'root',
            isVisible: true,
            parent: null,
            xpath: '',
            cssSelector: '',
            attributes: {},
            children: []
        }),
        selectorMap: new Map(),
        tabId: 0,
        url: url || '',
        title: title || '',
        screenshot: null,
        pixelsAbove: 0,
        pixelsBelow: 0
    };
}
class Page {
    get browser() {
        return this._browser;
    }
    get puppeteerPage() {
        return this._puppeteerPage;
    }
    get validWebPage() {
        return this._validWebPage;
    }
    get attached() {
        return this._validWebPage && null !== this._puppeteerPage;
    }
    async executeScript(page, options) {
        if (!page) throw new Error('Puppeteer页面未连接');
        if (options.contents && options.contents.length > 0) for (const content of options.contents){
            await page.evaluateOnNewDocument(content);
            logger.info(`已注入脚本文件`);
        }
    }
    async attachPuppeteer() {
        if (!this._validWebPage) return false;
        if (this._puppeteerPage) return true;
        logger.info('attaching puppeteer');
        const localBrowser = new browser_namespaceObject.LocalBrowser();
        await localBrowser.launch();
        const browser = await localBrowser.getBrowser();
        this._browser = browser;
        const [page] = await browser.pages();
        await this.executeScript(page, {
            contents: [
                (0, external_utils_js_namespaceObject.getBuildDomTreeScript)()
            ]
        });
        await page.goto(this._state.url);
        this._puppeteerPage = page;
        await this._addAntiDetectionScripts();
        return true;
    }
    async _addAntiDetectionScripts() {
        if (!this._puppeteerPage) return;
        await this._puppeteerPage.evaluateOnNewDocument(`
      // Webdriver property
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined
      });

      // Languages
      // Object.defineProperty(navigator, 'languages', {
      //   get: () => ['en-US', 'zh-CN']
      // });

      // Plugins
      // Object.defineProperty(navigator, 'plugins', {
      //   get: () => [1, 2, 3, 4, 5]
      // });

      // Chrome runtime
      window.chrome = { runtime: {} };

      // Permissions
      const originalQuery = window.navigator.permissions.query;
      window.navigator.permissions.query = (parameters) => (
        parameters.name === 'notifications' ?
          Promise.resolve({ state: Notification.permission }) :
          originalQuery(parameters)
      );

      // Shadow DOM
      (function () {
        const originalAttachShadow = Element.prototype.attachShadow;
        Element.prototype.attachShadow = function attachShadow(options) {
          return originalAttachShadow.call(this, { ...options, mode: "open" });
        };
      })();
    `);
    }
    async detachPuppeteer() {
        if (this._browser) {
            await this._browser.disconnect();
            this._browser = null;
            this._puppeteerPage = null;
            this._state = build_initial_state();
        }
    }
    async removeHighlight() {
        if (this._config.highlightElements && this._validWebPage) await (0, service_js_namespaceObject.removeHighlights)(this._puppeteerPage);
    }
    async getClickableElements(focusElement) {
        if (!this._validWebPage) return null;
        return (0, service_js_namespaceObject.getClickableElements)(this._puppeteerPage, this._config.highlightElements, focusElement, this._config.viewportExpansion);
    }
    async getScrollInfo() {
        if (!this._validWebPage) return [
            0,
            0
        ];
        return (0, service_js_namespaceObject.getScrollInfo)(this._puppeteerPage);
    }
    async getContent() {
        if (!this._puppeteerPage) throw new Error('Puppeteer page is not connected');
        return await this._puppeteerPage.content();
    }
    async getMarkdownContent(selector) {
        if (!this._validWebPage) return '';
        return (0, service_js_namespaceObject.getMarkdownContent)(this._puppeteerPage, selector);
    }
    async getReadabilityContent() {
        if (!this._validWebPage) return null;
        return (0, service_js_namespaceObject.getReadabilityContent)(this._puppeteerPage);
    }
    async getState() {
        if (!this._validWebPage) return build_initial_state();
        await this.waitForPageAndFramesLoad();
        const state = await this._updateState();
        return state;
    }
    async _updateState(useVision = true, focusElement = -1) {
        try {
            await this._puppeteerPage.evaluate('1');
        } catch (error) {
            logger.warning('Current page is no longer accessible:', error);
            if (this._browser) {
                const pages = await this._browser.pages();
                if (pages.length > 0) this._puppeteerPage = pages[0];
                else throw new Error('Browser closed: no valid pages available');
            }
        }
        try {
            var _this__puppeteerPage, _this__puppeteerPage1;
            await this.removeHighlight();
            const content = await this.getClickableElements(focusElement);
            if (!content) {
                logger.warning('Failed to get clickable elements');
                return this._state;
            }
            if ('selectorMap' in content) logger.debug('content.selectorMap:', content.selectorMap.size);
            else logger.debug('content.selectorMap: not found');
            if ('elementTree' in content) {
                var _content_elementTree;
                logger.debug('content.elementTree:', null === (_content_elementTree = content.elementTree) || void 0 === _content_elementTree ? void 0 : _content_elementTree.tagName);
            } else logger.debug('content.elementTree: not found');
            const screenshot = useVision ? await this.takeScreenshot() : null;
            const [pixelsAbove, pixelsBelow] = await this.getScrollInfo();
            this._state.elementTree = content.elementTree;
            this._state.selectorMap = content.selectorMap;
            this._state.url = (null === (_this__puppeteerPage = this._puppeteerPage) || void 0 === _this__puppeteerPage ? void 0 : _this__puppeteerPage.url()) || '';
            this._state.title = await (null === (_this__puppeteerPage1 = this._puppeteerPage) || void 0 === _this__puppeteerPage1 ? void 0 : _this__puppeteerPage1.title()) || '';
            this._state.screenshot = screenshot;
            this._state.pixelsAbove = pixelsAbove;
            this._state.pixelsBelow = pixelsBelow;
            return this._state;
        } catch (error) {
            logger.error('Failed to update state:', error);
            return this._state;
        }
    }
    async takeScreenshot(fullPage = false) {
        if (!this._puppeteerPage) throw new Error('Puppeteer page is not connected');
        try {
            await this._puppeteerPage.evaluate(()=>{
                const styleId = 'puppeteer-disable-animations';
                if (!document.getElementById(styleId)) {
                    const style = document.createElement('style');
                    style.id = styleId;
                    style.textContent = `
            *, *::before, *::after {
              animation: none !important;
              transition: none !important;
            }
          `;
                    document.head.appendChild(style);
                }
            });
            const screenshot = await this._puppeteerPage.screenshot({
                fullPage: fullPage,
                encoding: 'base64',
                type: 'jpeg',
                quality: 80
            });
            await this._puppeteerPage.evaluate(()=>{
                const style = document.getElementById('puppeteer-disable-animations');
                if (style) style.remove();
            });
            return screenshot;
        } catch (error) {
            logger.error('Failed to take screenshot:', error);
            throw error;
        }
    }
    url() {
        if (this._puppeteerPage) return this._puppeteerPage.url();
        return this._state.url;
    }
    async title() {
        if (this._puppeteerPage) return await this._puppeteerPage.title();
        return this._state.title;
    }
    async navigateTo(url) {
        if (!this._puppeteerPage) return;
        logger.info('navigateTo', url);
        try {
            await Promise.all([
                this.waitForPageAndFramesLoad(),
                this._puppeteerPage.goto(url)
            ]);
            logger.info('navigateTo complete');
        } catch (error) {
            if (error instanceof Error && error.message.includes('timeout')) logger.warning('Navigation timeout, but page might still be usable:', error);
            else {
                logger.error('NavigationTo failed:', error);
                throw error;
            }
        }
    }
    async refreshPage() {
        if (!this._puppeteerPage) return;
        try {
            await Promise.all([
                this.waitForPageAndFramesLoad(),
                this._puppeteerPage.reload()
            ]);
            logger.info('Page refresh complete');
        } catch (error) {
            if (error instanceof Error && error.message.includes('timeout')) logger.warning('Refresh timeout, but page might still be usable:', error);
            else {
                logger.error('Page refresh failed:', error);
                throw error;
            }
        }
    }
    async goBack() {
        if (!this._puppeteerPage) return;
        try {
            await Promise.all([
                this.waitForPageAndFramesLoad(),
                this._puppeteerPage.goBack()
            ]);
            logger.info('Navigation back completed');
        } catch (error) {
            if (error instanceof Error && error.message.includes('timeout')) logger.warning('Back navigation timeout, but page might still be usable:', error);
            else {
                logger.error('Could not navigate back:', error);
                throw error;
            }
        }
    }
    async goForward() {
        if (!this._puppeteerPage) return;
        try {
            await Promise.all([
                this.waitForPageAndFramesLoad(),
                this._puppeteerPage.goForward()
            ]);
            logger.info('Navigation forward completed');
        } catch (error) {
            if (error instanceof Error && error.message.includes('timeout')) logger.warning('Forward navigation timeout, but page might still be usable:', error);
            else {
                logger.error('Could not navigate forward:', error);
                throw error;
            }
        }
    }
    async scrollDown(amount) {
        if (this._puppeteerPage) {
            if (amount) {
                var _this__puppeteerPage;
                await (null === (_this__puppeteerPage = this._puppeteerPage) || void 0 === _this__puppeteerPage ? void 0 : _this__puppeteerPage.evaluate(`window.scrollBy(0, ${amount});`));
            } else {
                var _this__puppeteerPage1;
                await (null === (_this__puppeteerPage1 = this._puppeteerPage) || void 0 === _this__puppeteerPage1 ? void 0 : _this__puppeteerPage1.evaluate('window.scrollBy(0, window.innerHeight);'));
            }
        }
    }
    async scrollUp(amount) {
        if (this._puppeteerPage) {
            if (amount) {
                var _this__puppeteerPage;
                await (null === (_this__puppeteerPage = this._puppeteerPage) || void 0 === _this__puppeteerPage ? void 0 : _this__puppeteerPage.evaluate(`window.scrollBy(0, -${amount});`));
            } else {
                var _this__puppeteerPage1;
                await (null === (_this__puppeteerPage1 = this._puppeteerPage) || void 0 === _this__puppeteerPage1 ? void 0 : _this__puppeteerPage1.evaluate('window.scrollBy(0, -window.innerHeight);'));
            }
        }
    }
    async sendKeys(keys) {
        if (!this._puppeteerPage) throw new Error('Puppeteer page is not connected');
        const keyParts = keys.split('+');
        const modifiers = keyParts.slice(0, -1);
        const mainKey = keyParts[keyParts.length - 1];
        try {
            for (const modifier of modifiers)await this._puppeteerPage.keyboard.down(this._convertKey(modifier));
            await Promise.all([
                this._puppeteerPage.keyboard.press(this._convertKey(mainKey)),
                this.waitForPageAndFramesLoad()
            ]);
            logger.info('sendKeys complete', keys);
        } catch (error) {
            logger.error('Failed to send keys:', error);
            throw new Error(`Failed to send keys: ${error instanceof Error ? error.message : String(error)}`);
        } finally{
            for (const modifier of [
                ...modifiers
            ].reverse())try {
                await this._puppeteerPage.keyboard.up(this._convertKey(modifier));
            } catch (releaseError) {
                logger.error('Failed to release modifier:', modifier, releaseError);
            }
        }
    }
    _convertKey(key) {
        const lowerKey = key.trim().toLowerCase();
        const keyMap = {
            a: 'KeyA',
            b: 'KeyB',
            c: 'KeyC',
            d: 'KeyD',
            e: 'KeyE',
            f: 'KeyF',
            g: 'KeyG',
            h: 'KeyH',
            i: 'KeyI',
            j: 'KeyJ',
            k: 'KeyK',
            l: 'KeyL',
            m: 'KeyM',
            n: 'KeyN',
            o: 'KeyO',
            p: 'KeyP',
            q: 'KeyQ',
            r: 'KeyR',
            s: 'KeyS',
            t: 'KeyT',
            u: 'KeyU',
            v: 'KeyV',
            w: 'KeyW',
            x: 'KeyX',
            y: 'KeyY',
            z: 'KeyZ',
            0: 'Digit0',
            1: 'Digit1',
            2: 'Digit2',
            3: 'Digit3',
            4: 'Digit4',
            5: 'Digit5',
            6: 'Digit6',
            7: 'Digit7',
            8: 'Digit8',
            9: 'Digit9',
            control: 'Control',
            shift: 'Shift',
            alt: 'Alt',
            meta: 'Meta',
            enter: 'Enter',
            backspace: 'Backspace',
            delete: 'Delete',
            arrowleft: 'ArrowLeft',
            arrowright: 'ArrowRight',
            arrowup: 'ArrowUp',
            arrowdown: 'ArrowDown',
            escape: 'Escape',
            tab: 'Tab',
            space: 'Space'
        };
        const convertedKey = keyMap[lowerKey] || key;
        logger.info('convertedKey', convertedKey);
        return convertedKey;
    }
    async scrollToText(text) {
        if (!this._puppeteerPage) throw new Error('Puppeteer is not connected');
        try {
            const selectors = [
                `::-p-text(${text})`,
                `::-p-xpath(//*[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '${text.toLowerCase()}')])`
            ];
            for (const selector of selectors)try {
                const element = await this._puppeteerPage.$(selector);
                if (element) {
                    const isVisible = await element.evaluate((el)=>{
                        const style = window.getComputedStyle(el);
                        return 'none' !== style.display && 'hidden' !== style.visibility && '0' !== style.opacity;
                    });
                    if (isVisible) {
                        await this._scrollIntoViewIfNeeded(element);
                        await new Promise((resolve)=>setTimeout(resolve, 500));
                        return true;
                    }
                }
            } catch (e) {
                logger.debug(`Locator attempt failed: ${e}`);
            }
            return false;
        } catch (error) {
            throw new Error(error instanceof Error ? error.message : String(error));
        }
    }
    async getDropdownOptions(index) {
        const selectorMap = this.getSelectorMap();
        const element = null == selectorMap ? void 0 : selectorMap.get(index);
        if (!element || !this._puppeteerPage) throw new Error('Element not found or puppeteer is not connected');
        try {
            const elementHandle = await this.locateElement(element);
            if (!elementHandle) throw new Error('Dropdown element not found');
            const options = await elementHandle.evaluate((select)=>{
                if (!(select instanceof HTMLSelectElement)) throw new Error('Element is not a select element');
                return Array.from(select.options).map((option)=>({
                        index: option.index,
                        text: option.text,
                        value: option.value
                    }));
            });
            if (!options.length) throw new Error('No options found in dropdown');
            return options;
        } catch (error) {
            throw new Error(`Failed to get dropdown options: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async selectDropdownOption(index, text) {
        var _element_tagName;
        const selectorMap = this.getSelectorMap();
        const element = null == selectorMap ? void 0 : selectorMap.get(index);
        if (!element || !this._puppeteerPage) throw new Error('Element not found or puppeteer is not connected');
        logger.debug(`Attempting to select '${text}' from dropdown`);
        logger.debug(`Element attributes: ${JSON.stringify(element.attributes)}`);
        logger.debug(`Element tag: ${element.tagName}`);
        if ((null === (_element_tagName = element.tagName) || void 0 === _element_tagName ? void 0 : _element_tagName.toLowerCase()) !== 'select') {
            const msg = `Cannot select option: Element with index ${index} is a ${element.tagName}, not a SELECT`;
            logger.error(msg);
            throw new Error(msg);
        }
        try {
            const elementHandle = await this.locateElement(element);
            if (!elementHandle) throw new Error(`Dropdown element with index ${index} not found`);
            const result = await elementHandle.evaluate((select, optionText, elementIndex)=>{
                if (!(select instanceof HTMLSelectElement)) return {
                    found: false,
                    message: `Element with index ${elementIndex} is not a SELECT`
                };
                const options = Array.from(select.options);
                const option = options.find((opt)=>opt.text.trim() === optionText);
                if (!option) {
                    const availableOptions = options.map((o)=>o.text.trim()).join('", "');
                    return {
                        found: false,
                        message: `Option "${optionText}" not found in dropdown element with index ${elementIndex}. Available options: "${availableOptions}"`
                    };
                }
                const previousValue = select.value;
                select.value = option.value;
                if (previousValue !== option.value) {
                    select.dispatchEvent(new Event('change', {
                        bubbles: true
                    }));
                    select.dispatchEvent(new Event('input', {
                        bubbles: true
                    }));
                }
                return {
                    found: true,
                    message: `Selected option "${optionText}" with value "${option.value}"`
                };
            }, text, index);
            logger.debug('Selection result:', result);
            return result.message;
        } catch (error) {
            const errorMessage = `${error instanceof Error ? error.message : String(error)}`;
            logger.error(errorMessage);
            throw new Error(errorMessage);
        }
    }
    async locateElement(element) {
        return await (0, external_utils_js_namespaceObject_1.locateElement)(this._puppeteerPage, element, this._config);
    }
    async inputTextElementNode(useVision, elementNode, text) {
        if (!this._puppeteerPage) throw new Error('Puppeteer is not connected');
        try {
            if (void 0 !== elementNode.highlightIndex) await this._updateState(useVision, elementNode.highlightIndex);
            const element = await this.locateElement(elementNode);
            if (!element) throw new Error(`Element: ${elementNode} not found`);
            await this._scrollIntoViewIfNeeded(element);
            await element.evaluate((el)=>{
                if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {
                    el.value = '';
                    el.dispatchEvent(new Event('input', {
                        bubbles: true
                    }));
                    el.dispatchEvent(new Event('change', {
                        bubbles: true
                    }));
                }
            });
            await element.type(text);
        } catch (error) {
            throw new Error(`Failed to input text into element: ${elementNode}. Error: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async _scrollIntoViewIfNeeded(element, timeout = 2500) {
        await (0, external_utils_js_namespaceObject_1.scrollIntoViewIfNeeded)(element, timeout);
    }
    async clickElementNode(useVision, elementNode) {
        if (!this._puppeteerPage) throw new Error('Puppeteer is not connected');
        try {
            if (void 0 !== elementNode.highlightIndex) await this._updateState(useVision, elementNode.highlightIndex);
            const element = await this.locateElement(elementNode);
            if (!element) throw new Error(`Element: ${elementNode} not found`);
            await this._scrollIntoViewIfNeeded(element);
            try {
                await Promise.race([
                    element.click(),
                    new Promise((_, reject)=>setTimeout(()=>reject(new Error('Click timeout')), 2000))
                ]);
            } catch (error) {
                logger.info('Failed to click element, trying again', error);
                try {
                    await element.evaluate((el)=>el.click());
                } catch (secondError) {
                    throw new Error(`Failed to click element: ${secondError instanceof Error ? secondError.message : String(secondError)}`);
                }
            }
        } catch (error) {
            throw new Error(`Failed to click element: ${elementNode}. Error: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    getSelectorMap() {
        return this._state.selectorMap;
    }
    async getElementByIndex(index) {
        const selectorMap = this.getSelectorMap();
        const element = selectorMap.get(index);
        if (!element) return null;
        return await this.locateElement(element);
    }
    getDomElementByIndex(index) {
        const selectorMap = this.getSelectorMap();
        return selectorMap.get(index) || null;
    }
    isFileUploader(elementNode, maxDepth = 3, currentDepth = 0) {
        if (currentDepth > maxDepth) return false;
        if ('input' === elementNode.tagName) {
            var _attributes_type;
            const attributes = elementNode.attributes;
            if ((null === (_attributes_type = attributes['type']) || void 0 === _attributes_type ? void 0 : _attributes_type.toLowerCase()) === 'file' || !!attributes['accept']) return true;
        }
        if (elementNode.children && currentDepth < maxDepth) {
            for (const child of elementNode.children)if ('tagName' in child) {
                if (this.isFileUploader(child, maxDepth, currentDepth + 1)) return true;
            }
        }
        return false;
    }
    async waitForPageAndFramesLoad(timeoutOverwrite) {
        await (0, external_utils_js_namespaceObject_1.waitForPageAndFramesLoad)(this._puppeteerPage, timeoutOverwrite, this._config);
    }
    constructor(url, title, config = {}){
        _define_property(this, "_browser", null);
        _define_property(this, "_puppeteerPage", null);
        _define_property(this, "_config", void 0);
        _define_property(this, "_state", void 0);
        _define_property(this, "_validWebPage", false);
        this._config = {
            ...external_types_js_namespaceObject.DEFAULT_BROWSER_CONTEXT_CONFIG,
            ...config
        };
        this._state = build_initial_state(url, title);
        this._validWebPage = url && url.startsWith('http') || false;
    }
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

//# sourceMappingURL=page.js.map