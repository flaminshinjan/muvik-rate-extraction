/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import * as __WEBPACK_EXTERNAL_MODULE__types_mjs_4ad50757__ from "./types.mjs";
async function scrollIntoViewIfNeeded(element, timeout = 2500) {
    const startTime = Date.now();
    while(true){
        const isVisible = await element.evaluate((el)=>{
            const rect = el.getBoundingClientRect();
            if (0 === rect.width || 0 === rect.height) return false;
            const style = window.getComputedStyle(el);
            if ('hidden' === style.visibility || 'none' === style.display || '0' === style.opacity) return false;
            const isInViewport = rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
            if (!isInViewport) {
                el.scrollIntoView({
                    behavior: 'auto',
                    block: 'center',
                    inline: 'center'
                });
                return false;
            }
            return true;
        });
        if (isVisible) break;
        if (Date.now() - startTime > timeout) throw new Error('Timed out while trying to scroll element into view');
        await new Promise((resolve)=>setTimeout(resolve, 100));
    }
}
async function locateElement(page, element, _options) {
    const options = {
        ...__WEBPACK_EXTERNAL_MODULE__types_mjs_4ad50757__.DEFAULT_BROWSER_CONTEXT_CONFIG,
        ..._options
    };
    if (!page) {
        console.warn('Puppeteer is not connected');
        return null;
    }
    let currentFrame = page;
    const parents = [];
    let current = element;
    while(current.parent){
        parents.push(current.parent);
        current = current.parent;
    }
    const iframes = parents.reverse().filter((item)=>'iframe' === item.tagName);
    for (const parent of iframes){
        const cssSelector = parent.enhancedCssSelectorForElement(options.includeDynamicAttributes);
        const frameElement = await currentFrame.$(cssSelector);
        if (!frameElement) {
            console.warn(`Could not find iframe with selector: ${cssSelector}`);
            return null;
        }
        const frame = await frameElement.contentFrame();
        if (!frame) {
            console.warn(`Could not access frame content for selector: ${cssSelector}`);
            return null;
        }
        currentFrame = frame;
    }
    const cssSelector = element.enhancedCssSelectorForElement(options.includeDynamicAttributes);
    try {
        const elementHandle = await currentFrame.$(cssSelector);
        if (elementHandle) {
            await scrollIntoViewIfNeeded(elementHandle);
            return elementHandle;
        }
    } catch (error) {
        console.error('Failed to locate element:', error);
    }
    return null;
}
async function waitForStableNetwork(page, _options) {
    const options = {
        ...__WEBPACK_EXTERNAL_MODULE__types_mjs_4ad50757__.DEFAULT_BROWSER_CONTEXT_CONFIG,
        ..._options
    };
    if (!page) throw new Error('Puppeteer page is not connected');
    const RELEVANT_RESOURCE_TYPES = new Set([
        'document',
        'stylesheet',
        'image',
        'font',
        "script",
        'iframe'
    ]);
    const RELEVANT_CONTENT_TYPES = new Set([
        'text/html',
        'text/css',
        "application/javascript",
        'image/',
        'font/',
        'application/json'
    ]);
    const IGNORED_URL_PATTERNS = new Set([
        'analytics',
        'tracking',
        'telemetry',
        'beacon',
        'metrics',
        'doubleclick',
        'adsystem',
        'adserver',
        'advertising',
        'facebook.com/plugins',
        'platform.twitter',
        'linkedin.com/embed',
        'livechat',
        'zendesk',
        'intercom',
        'crisp.chat',
        'hotjar',
        'push-notifications',
        'onesignal',
        'pushwoosh',
        'heartbeat',
        'ping',
        'alive',
        'webrtc',
        'rtmp://',
        'wss://',
        'cloudfront.net',
        'fastly.net'
    ]);
    const pendingRequests = new Set();
    let lastActivity = Date.now();
    const onRequest = (request)=>{
        const resourceType = request.resourceType();
        if (!RELEVANT_RESOURCE_TYPES.has(resourceType)) return;
        if ([
            'websocket',
            'media',
            'eventsource',
            'manifest',
            'other'
        ].includes(resourceType)) return;
        const url = request.url().toLowerCase();
        if (Array.from(IGNORED_URL_PATTERNS).some((pattern)=>url.includes(pattern))) return;
        if (url.startsWith('data:') || url.startsWith('blob:')) return;
        const headers = request.headers();
        if ('prefetch' === headers['purpose'] || 'video' === headers['sec-fetch-dest'] || 'audio' === headers['sec-fetch-dest']) return;
        pendingRequests.add(request);
        lastActivity = Date.now();
    };
    const onResponse = (response)=>{
        var _response_headers_contenttype;
        const request = response.request();
        if (!pendingRequests.has(request)) return;
        const contentType = (null === (_response_headers_contenttype = response.headers()['content-type']) || void 0 === _response_headers_contenttype ? void 0 : _response_headers_contenttype.toLowerCase()) || '';
        if ([
            'streaming',
            'video',
            'audio',
            'webm',
            'mp4',
            'event-stream',
            'websocket',
            'protobuf'
        ].some((t)=>contentType.includes(t))) {
            pendingRequests.delete(request);
            return;
        }
        if (!Array.from(RELEVANT_CONTENT_TYPES).some((ct)=>contentType.includes(ct))) {
            pendingRequests.delete(request);
            return;
        }
        const contentLength = response.headers()['content-length'];
        if (contentLength && Number.parseInt(contentLength) > 5242880) {
            pendingRequests.delete(request);
            return;
        }
        pendingRequests.delete(request);
        lastActivity = Date.now();
    };
    page.on('request', onRequest);
    page.on('response', onResponse);
    try {
        const startTime = Date.now();
        while(true){
            await new Promise((resolve)=>setTimeout(resolve, 100));
            const now = Date.now();
            const timeSinceLastActivity = (now - lastActivity) / 1000;
            if (0 === pendingRequests.size && timeSinceLastActivity >= options.waitForNetworkIdlePageLoadTime) break;
            const elapsedTime = (now - startTime) / 1000;
            if (elapsedTime > options.maximumWaitPageLoadTime) {
                console.debug(`Network timeout after ${options.maximumWaitPageLoadTime}s with ${pendingRequests.size} pending requests:`, Array.from(pendingRequests).map((r)=>r.url()));
                break;
            }
        }
    } finally{
        page.off('request', onRequest);
        page.off('response', onResponse);
    }
    console.debug(`Network stabilized for ${options.waitForNetworkIdlePageLoadTime} seconds`);
}
async function waitForPageAndFramesLoad(page, timeoutOverwrite, _options) {
    const options = {
        ...__WEBPACK_EXTERNAL_MODULE__types_mjs_4ad50757__.DEFAULT_BROWSER_CONTEXT_CONFIG,
        ..._options
    };
    const startTime = Date.now();
    try {
        await waitForStableNetwork(page, options);
    } catch (error) {
        console.warn('Page load failed, continuing...');
    }
    const elapsed = (Date.now() - startTime) / 1000;
    const minWaitTime = timeoutOverwrite || options.minimumWaitPageLoadTime;
    const remaining = Math.max(minWaitTime - elapsed, 0);
    console.debug(`--Page loaded in ${elapsed.toFixed(2)} seconds, waiting for additional ${remaining.toFixed(2)} seconds`);
    if (remaining > 0) await new Promise((resolve)=>setTimeout(resolve, 1000 * remaining));
}
async function waitForPageLoadState(page, timeout) {
    const timeoutValue = timeout || 8000;
    await (null == page ? void 0 : page.waitForNavigation({
        timeout: timeoutValue
    }));
}
export { locateElement, scrollIntoViewIfNeeded, waitForPageAndFramesLoad, waitForPageLoadState, waitForStableNetwork };

//# sourceMappingURL=utils.mjs.map