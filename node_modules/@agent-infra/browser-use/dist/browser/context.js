/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    default: ()=>BrowserContext
});
const external_types_js_namespaceObject = require("./types.js");
const external_page_js_namespaceObject = require("./page.js");
var external_page_js_default = /*#__PURE__*/ __webpack_require__.n(external_page_js_namespaceObject);
const external_utils_js_namespaceObject = require("../utils.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const logger = (0, external_utils_js_namespaceObject.createLogger)('BrowserContext');
class BrowserContext {
    getConfig() {
        return this._config;
    }
    updateCurrentTabId(url) {
        this._currentTabId = url;
    }
    async _getOrCreatePage(url, forceUpdate = false) {
        const existingPage = this._attachedPages.get(url);
        if (existingPage) {
            logger.info('getOrCreatePage', url, 'already attached');
            if (!forceUpdate) return existingPage;
            await existingPage.detachPuppeteer();
            this._attachedPages.delete(url);
        }
        logger.info('getOrCreatePage', url, 'creating new page');
        return new (external_page_js_default())(url || '', '', this._config);
    }
    async cleanup() {
        const currentPage = await this.getCurrentPage();
        null == currentPage || currentPage.removeHighlight();
        for (const page of this._attachedPages.values())await page.detachPuppeteer();
        this._attachedPages.clear();
        this._currentTabId = null;
    }
    async attachPage(page) {
        if (this._attachedPages.has(page.url())) {
            logger.info('attachPage_has', page.url(), 'already attached');
            return true;
        }
        if (await page.attachPuppeteer()) {
            logger.info('attachPage', page.url(), 'attached');
            this._attachedPages.set(page.url(), page);
            return true;
        }
        return false;
    }
    async detachPage(url) {
        const page = this._attachedPages.get(url);
        if (page) {
            await page.detachPuppeteer();
            this._attachedPages.delete(url);
        }
    }
    async getCurrentPage() {
        if (!this._currentTabId) {
            const page = await this._getOrCreatePage('');
            await this.attachPage(page);
            this._currentTabId = page.url();
            return page;
        }
        const existingPage = this._attachedPages.get(this._currentTabId);
        if (!existingPage) {
            const page = await this._getOrCreatePage(this._currentTabId);
            await this.attachPage(page);
            return page;
        }
        return existingPage;
    }
    async getAllTabIds() {
        var _currentPage_browser;
        const currentPage = await this.getCurrentPage();
        if (!currentPage || !currentPage.attached) {
            logger.warning('No attached page found');
            return new Set();
        }
        const pages = await (null === (_currentPage_browser = currentPage.browser) || void 0 === _currentPage_browser ? void 0 : _currentPage_browser.pages());
        const tabs = (null == pages ? void 0 : pages.map((page)=>({
                url: page.url()
            }))) || [];
        return new Set(tabs.map((tab)=>tab.url).filter((url)=>void 0 !== url));
    }
    async waitForPageEvents(url, options = {}) {
        const { waitForNavigation = true, waitForLoad = true, timeoutMs = 5000 } = options;
        const page = this._attachedPages.get(url);
        if (!page || !page.attached || !page.puppeteerPage) {
            logger.warning(`waitForPageEvents failed, page ${url} is not attached`);
            return;
        }
        const puppeteerPage = page.puppeteerPage;
        const promises = [];
        if (waitForNavigation) {
            const navPromise = puppeteerPage.waitForNavigation({
                timeout: timeoutMs,
                waitUntil: 'domcontentloaded'
            }).catch((err)=>{
                logger.debug(`waitForPageEvents failed, navigation error: ${err.message}`);
            });
            promises.push(navPromise);
        }
        if (waitForLoad) {
            const loadPromise = puppeteerPage.waitForNavigation({
                timeout: timeoutMs,
                waitUntil: 'load'
            }).catch((err)=>{
                logger.debug(`waitForPageEvents failed, load error: ${err.message}`);
            });
            promises.push(loadPromise);
            const networkPromise = puppeteerPage.waitForNavigation({
                timeout: timeoutMs,
                waitUntil: 'networkidle0'
            }).catch((err)=>{
                logger.debug(`waitForPageEvents failed, network idle error: ${err.message}`);
            });
            promises.push(networkPromise);
        }
        const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>reject(new Error(`page operation timeout, waited ${timeoutMs} ms`)), timeoutMs));
        await Promise.race([
            Promise.all(promises),
            timeoutPromise
        ]).catch((error)=>{
            if (error.message.includes('page operation timeout')) throw error;
            logger.debug(`navigation error: ${error.message}`);
        });
        try {
            await puppeteerPage.waitForSelector('body', {
                timeout: timeoutMs / 2
            });
        } catch (error) {
            logger.warning(`waitForPageEvents failed, body not found: ${error}`);
        }
    }
    async switchTab(url) {
        logger.info('switchTab', url);
        const page = await this._getOrCreatePage(url);
        await this.attachPage(page);
        this._currentTabId = url;
        return page;
    }
    async navigateTo(url) {
        const page = await this.getCurrentPage();
        if (!page) {
            await this.openTab(url);
            return;
        }
        if (page.attached) {
            await page.navigateTo(url);
            return;
        }
        const updatedPage = await this._getOrCreatePage(url, true);
        await this.attachPage(updatedPage);
        this._currentTabId = url;
    }
    async openTab(url) {
        const page = await this._getOrCreatePage(url);
        await this.attachPage(page);
        this._currentTabId = url;
        return page;
    }
    async closeTab(url) {
        await this.detachPage(url);
        if (this._currentTabId === url) this._currentTabId = null;
    }
    removeAttachedPage(url) {
        this._attachedPages.delete(url);
        if (this._currentTabId === url) this._currentTabId = null;
    }
    async getState() {
        var _currentPage_browser;
        const currentPage = await this.getCurrentPage();
        const pageState = currentPage ? await currentPage.getState() : (0, external_page_js_namespaceObject.build_initial_state)();
        const pages = await (null === (_currentPage_browser = currentPage.browser) || void 0 === _currentPage_browser ? void 0 : _currentPage_browser.pages());
        const pageInfos = await Promise.all((null == pages ? void 0 : pages.map(async (page)=>({
                id: page.url(),
                url: page.url(),
                title: await page.title()
            }))) || []);
        const browserState = {
            ...pageState,
            pages: pageInfos
        };
        return browserState;
    }
    async removeHighlight() {
        const page = await this.getCurrentPage();
        if (page) await page.removeHighlight();
    }
    constructor(config){
        _define_property(this, "_config", void 0);
        _define_property(this, "_currentTabId", null);
        _define_property(this, "_attachedPages", new Map());
        this._config = {
            ...external_types_js_namespaceObject.DEFAULT_BROWSER_CONTEXT_CONFIG,
            ...config
        };
    }
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

//# sourceMappingURL=context.js.map