/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    BaseBrowser: ()=>BaseBrowser
});
const logger_namespaceObject = require("@agent-infra/logger");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class BaseBrowser {
    async isBrowserAlive() {
        if (!this.browser) return false;
        try {
            const version = await this.browser.version();
            this.logger.info('Browser version:', version);
            return true;
        } catch (error) {
            this.logger.warn('Browser instance is no longer active:', error);
            this.browser = null;
            return false;
        }
    }
    getBrowser() {
        if (!this.browser) throw new Error('Browser not launched');
        return this.browser;
    }
    async setupPageListener() {
        if (!this.browser) return;
        this.browser.on('targetcreated', async (target)=>{
            const page = await target.page();
            if (page) {
                this.logger.info('New page created:', await page.url());
                this.activePage = page;
                page.once('close', ()=>{
                    if (this.activePage === page) this.activePage = null;
                });
                page.once('error', ()=>{
                    if (this.activePage === page) this.activePage = null;
                });
            }
        });
    }
    async close() {
        this.logger.info('Closing browser');
        try {
            var _this_browser;
            await (null === (_this_browser = this.browser) || void 0 === _this_browser ? void 0 : _this_browser.close());
            this.browser = null;
            this.logger.success('Browser closed successfully');
        } catch (error) {
            this.logger.error('Failed to close browser:', error);
            throw error;
        }
    }
    async evaluateOnNewPage(options) {
        const { url, pageFunction, pageFunctionParams, beforePageLoad, afterPageLoad, beforeSendResult, waitForOptions } = options;
        const page = await this.browser.newPage();
        try {
            await (null == beforePageLoad ? void 0 : beforePageLoad(page));
            await page.goto(url, {
                waitUntil: 'networkidle2',
                ...waitForOptions
            });
            await (null == afterPageLoad ? void 0 : afterPageLoad(page));
            const _window = await page.evaluateHandle(()=>window);
            const result = await page.evaluate(pageFunction, _window, ...pageFunctionParams);
            await (null == beforeSendResult ? void 0 : beforeSendResult(page, result));
            await _window.dispose();
            await page.close();
            return result;
        } catch (error) {
            await page.close();
            throw error;
        }
    }
    async createPage() {
        if (!this.browser) {
            this.logger.error('No active browser');
            throw new Error('Browser not launched');
        }
        const page = await this.browser.newPage();
        return page;
    }
    async getActivePage() {
        if (!this.browser) throw new Error('Browser not launched');
        if (this.activePage) try {
            await this.activePage.evaluate(()=>document.readyState);
            return this.activePage;
        } catch (e) {
            this.logger.warn('Active page no longer available:', e);
            this.activePage = null;
        }
        const pages = await this.browser.pages();
        if (0 === pages.length) {
            this.activePage = await this.createPage();
            return this.activePage;
        }
        for(let i = pages.length - 1; i >= 0; i--){
            const page = pages[i];
            try {
                await page.evaluate(()=>document.readyState);
                this.activePage = page;
                return page;
            } catch (e) {
                continue;
            }
        }
        throw new Error('No active page found');
    }
    constructor(options){
        _define_property(this, "browser", null);
        _define_property(this, "logger", void 0);
        _define_property(this, "activePage", null);
        this.logger = (null == options ? void 0 : options.logger) ?? logger_namespaceObject.defaultLogger;
        this.logger.info('Browser Options:', options);
    }
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

//# sourceMappingURL=base-browser.js.map